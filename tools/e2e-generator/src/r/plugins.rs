use super::render::{escape_r_string_content, render_r_value, to_title_case};
use crate::fixtures::{Fixture, ObjectPropertyAssertion};
use anyhow::{Context, Result, bail};
use camino::Utf8Path;
use std::fmt::Write as _;
use std::fs;

/// Generate plugin API test file
pub fn generate_plugin_api_tests(fixtures: &[&Fixture], test_dir: &Utf8Path) -> Result<()> {
    let mut buffer = String::new();

    writeln!(buffer, "# Code generated by kreuzberg-e2e-generator. DO NOT EDIT.")?;
    writeln!(
        buffer,
        "# To regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang r"
    )?;
    writeln!(buffer, "# nolint start")?;
    writeln!(buffer)?;
    writeln!(buffer, "library(testthat)")?;
    writeln!(buffer, "library(kreuzberg)")?;
    writeln!(buffer)?;

    let mut grouped_map: std::collections::HashMap<String, Vec<&Fixture>> = std::collections::HashMap::new();
    for fixture in fixtures.iter() {
        let category = fixture
            .api_category
            .as_ref()
            .with_context(|| format!("Fixture '{}' missing api_category", fixture.id))?
            .clone();
        grouped_map.entry(category).or_default().push(fixture);
    }
    let mut grouped: Vec<_> = grouped_map.into_iter().collect();
    grouped.sort_by(|a, b| a.0.cmp(&b.0));

    for (category, mut fixtures) in grouped {
        fixtures.sort_by(|a, b| a.id.cmp(&b.id));
        let category_title = to_title_case(&category);
        writeln!(
            buffer,
            "test_that(\"{} API tests\", {{",
            escape_r_string_content(&category_title)
        )?;

        for fixture in fixtures {
            buffer.push_str(&render_plugin_test(fixture)?);
        }

        writeln!(buffer, "}})")?;
        writeln!(buffer)?;
    }

    writeln!(buffer, "# nolint end")?;

    let path = test_dir.join("test-plugin-apis.R");
    fs::write(&path, buffer).with_context(|| format!("Writing {}", path))?;

    Ok(())
}

fn render_plugin_test(fixture: &Fixture) -> Result<String> {
    let mut buffer = String::new();
    let test_spec = fixture
        .test_spec
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing test_spec", fixture.id))?;

    match test_spec.pattern.as_str() {
        "simple_list" => render_simple_list_test(&mut buffer, fixture)?,
        "clear_registry" => render_clear_registry_test(&mut buffer, fixture)?,
        "graceful_unregister" => render_graceful_unregister_test(&mut buffer, fixture)?,
        "config_from_file" => render_config_from_file_test(&mut buffer, fixture)?,
        "config_discover" => render_config_discover_test(&mut buffer, fixture)?,
        "mime_from_bytes" => render_mime_from_bytes_test(&mut buffer, fixture)?,
        "mime_from_path" => render_mime_from_path_test(&mut buffer, fixture)?,
        "mime_extension_lookup" => render_mime_extension_lookup_test(&mut buffer, fixture)?,
        _ => {
            bail!("Unknown plugin test pattern: {}", test_spec.pattern);
        }
    }

    Ok(buffer)
}

fn render_simple_list_test(buffer: &mut String, fixture: &Fixture) -> Result<()> {
    let test_spec = fixture.test_spec.as_ref().unwrap();
    let function_name = &test_spec.function_call.name;

    writeln!(buffer, "  # {}", fixture.description)?;
    writeln!(buffer, "  result <- {}()", function_name)?;
    writeln!(buffer, "  expect_true(is.character(result) || is.list(result))")?;

    if let Some(contains) = &test_spec.assertions.list_contains {
        writeln!(
            buffer,
            "  expect_true(\"{}\" %in% result)",
            escape_r_string_content(contains)
        )?;
    }
    writeln!(buffer)?;

    Ok(())
}

fn render_clear_registry_test(buffer: &mut String, fixture: &Fixture) -> Result<()> {
    let test_spec = fixture.test_spec.as_ref().unwrap();
    let clear_function = &test_spec.function_call.name;
    let list_function = clear_function.replace("clear_", "list_");

    writeln!(buffer, "  # {}", fixture.description)?;
    writeln!(buffer, "  {}()", clear_function)?;

    if test_spec.assertions.verify_cleanup {
        writeln!(buffer, "  result <- {}()", list_function)?;
        writeln!(buffer, "  expect_length(result, 0L)")?;
    }
    writeln!(buffer)?;

    Ok(())
}

fn render_graceful_unregister_test(buffer: &mut String, fixture: &Fixture) -> Result<()> {
    let test_spec = fixture.test_spec.as_ref().unwrap();
    let function_name = &test_spec.function_call.name;

    let arg = test_spec
        .function_call
        .args
        .first()
        .and_then(|v| v.as_str())
        .unwrap_or("nonexistent-item-xyz");

    writeln!(buffer, "  # {}", fixture.description)?;
    writeln!(
        buffer,
        "  expect_no_error({}(\"{}\"))",
        function_name,
        escape_r_string_content(arg)
    )?;
    writeln!(buffer)?;

    Ok(())
}

fn render_config_from_file_test(buffer: &mut String, fixture: &Fixture) -> Result<()> {
    let test_spec = fixture.test_spec.as_ref().unwrap();
    let setup = test_spec
        .setup
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing setup", fixture.id))?;

    let temp_file_name = setup
        .temp_file_name
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing temp_file_name", fixture.id))?;
    let temp_file_content = setup
        .temp_file_content
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing temp_file_content", fixture.id))?;

    writeln!(buffer, "  # {}", fixture.description)?;
    writeln!(buffer, "  withr::with_tempdir({{ tmpdir <- getwd()")?;
    writeln!(
        buffer,
        "    config_path <- file.path(tmpdir, \"{}\")",
        escape_r_string_content(temp_file_name)
    )?;
    writeln!(buffer, "    writeLines(c(")?;
    for (i, line) in temp_file_content.lines().enumerate() {
        if i > 0 {
            write!(buffer, ",")?;
        }
        write!(buffer, "      \"{}\"", escape_r_string_content(line))?;
    }
    writeln!(buffer, "\n    ), config_path)")?;
    writeln!(buffer)?;

    let method_name = &test_spec.function_call.name;
    writeln!(buffer, "    config <- {}(config_path)", method_name)?;

    for prop in &test_spec.assertions.object_properties {
        render_object_property_assertion(buffer, "config", prop, "    ")?;
    }
    writeln!(buffer, "  }})")?;
    writeln!(buffer)?;

    Ok(())
}

fn render_config_discover_test(buffer: &mut String, fixture: &Fixture) -> Result<()> {
    let test_spec = fixture.test_spec.as_ref().unwrap();
    let setup = test_spec
        .setup
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing setup", fixture.id))?;

    let temp_file_name = setup
        .temp_file_name
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing temp_file_name", fixture.id))?;
    let temp_file_content = setup
        .temp_file_content
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing temp_file_content", fixture.id))?;
    let subdirectory_name = setup
        .subdirectory_name
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing subdirectory_name", fixture.id))?;

    writeln!(buffer, "  # {}", fixture.description)?;
    writeln!(buffer, "  withr::with_tempdir({{ tmpdir <- getwd()")?;
    writeln!(
        buffer,
        "    config_path <- file.path(tmpdir, \"{}\")",
        escape_r_string_content(temp_file_name)
    )?;
    writeln!(buffer, "    writeLines(c(")?;
    for (i, line) in temp_file_content.lines().enumerate() {
        if i > 0 {
            write!(buffer, ",")?;
        }
        write!(buffer, "      \"{}\"", escape_r_string_content(line))?;
    }
    writeln!(buffer, "\n    ), config_path)")?;
    writeln!(buffer)?;
    writeln!(
        buffer,
        "    subdir <- file.path(tmpdir, \"{}\")",
        escape_r_string_content(subdirectory_name)
    )?;
    writeln!(buffer, "    dir.create(subdir, recursive = TRUE)")?;
    writeln!(buffer)?;

    let method_name = &test_spec.function_call.name;
    writeln!(buffer, "    withr::with_dir(subdir, {{")?;
    writeln!(buffer, "      config <- {}()", method_name)?;

    for prop in &test_spec.assertions.object_properties {
        render_object_property_assertion(buffer, "config", prop, "      ")?;
    }
    writeln!(buffer, "    }})")?;
    writeln!(buffer, "  }})")?;
    writeln!(buffer)?;

    Ok(())
}

fn render_mime_from_bytes_test(buffer: &mut String, fixture: &Fixture) -> Result<()> {
    let test_spec = fixture.test_spec.as_ref().unwrap();
    let setup = test_spec
        .setup
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing setup", fixture.id))?;
    let test_data = setup
        .test_data
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing test_data", fixture.id))?;
    let function_name = &test_spec.function_call.name;

    writeln!(buffer, "  # {}", fixture.description)?;
    writeln!(
        buffer,
        "  test_bytes <- charToRaw(\"{}\")",
        escape_r_string_content(test_data)
    )?;
    writeln!(buffer, "  result <- {}(test_bytes)", function_name)?;

    if let Some(contains) = &test_spec.assertions.string_contains {
        writeln!(
            buffer,
            "  expect_true(grepl(\"{}\", tolower(result), fixed = TRUE))",
            escape_r_string_content(&contains.to_lowercase())
        )?;
    }
    writeln!(buffer)?;

    Ok(())
}

fn render_mime_from_path_test(buffer: &mut String, fixture: &Fixture) -> Result<()> {
    let test_spec = fixture.test_spec.as_ref().unwrap();
    let function_name = &test_spec.function_call.name;

    writeln!(buffer, "  # {}", fixture.description)?;
    writeln!(buffer, "  withr::with_tempdir({{ tmpdir <- getwd()")?;
    writeln!(buffer, "    test_file <- file.path(tmpdir, \"test.txt\")")?;
    writeln!(buffer, "    writeLines(\"Hello, world!\", test_file)")?;
    writeln!(buffer)?;
    writeln!(buffer, "    result <- {}(test_file)", function_name)?;

    if let Some(contains) = &test_spec.assertions.string_contains {
        writeln!(
            buffer,
            "    expect_true(grepl(\"{}\", tolower(result), fixed = TRUE))",
            escape_r_string_content(&contains.to_lowercase())
        )?;
    }
    writeln!(buffer, "  }})")?;
    writeln!(buffer)?;

    Ok(())
}

fn render_mime_extension_lookup_test(buffer: &mut String, fixture: &Fixture) -> Result<()> {
    let test_spec = fixture.test_spec.as_ref().unwrap();
    let function_name = &test_spec.function_call.name;

    let mime_type = test_spec
        .function_call
        .args
        .first()
        .and_then(|v| v.as_str())
        .unwrap_or("application/pdf");

    writeln!(buffer, "  # {}", fixture.description)?;
    writeln!(
        buffer,
        "  result <- {}(\"{}\")",
        function_name,
        escape_r_string_content(mime_type)
    )?;
    writeln!(buffer, "  expect_true(is.character(result))")?;

    if let Some(contains) = &test_spec.assertions.list_contains {
        writeln!(
            buffer,
            "  expect_true(\"{}\" %in% result)",
            escape_r_string_content(contains)
        )?;
    }
    writeln!(buffer)?;

    Ok(())
}

fn render_object_property_assertion(
    buffer: &mut String,
    var_name: &str,
    prop: &ObjectPropertyAssertion,
    indent: &str,
) -> Result<()> {
    let path_parts: Vec<&str> = prop.path.split('.').collect();
    // Build R accessor chain: config$chunking$max_chars
    let r_access = format!("{}${}", var_name, path_parts.join("$"));

    if let Some(exists) = prop.exists {
        if exists {
            writeln!(buffer, "{}expect_false(is.null({}))", indent, r_access)?;
        } else {
            writeln!(buffer, "{}expect_true(is.null({}))", indent, r_access)?;
        }
    }

    if let Some(value) = &prop.value {
        match value {
            serde_json::Value::Number(n) => {
                writeln!(buffer, "{}expect_equal({}, {})", indent, r_access, n)?;
            }
            serde_json::Value::Bool(b) => {
                writeln!(
                    buffer,
                    "{}expect_equal({}, {})",
                    indent,
                    r_access,
                    if *b { "TRUE" } else { "FALSE" }
                )?;
            }
            serde_json::Value::String(s) => {
                writeln!(
                    buffer,
                    "{}expect_equal({}, \"{}\")",
                    indent,
                    r_access,
                    escape_r_string_content(s)
                )?;
            }
            _ => {
                writeln!(
                    buffer,
                    "{}expect_equal({}, {})",
                    indent,
                    r_access,
                    render_r_value(value)
                )?;
            }
        }
    }

    Ok(())
}
