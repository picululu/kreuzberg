mod assertions;
mod helpers;
mod plugins;
mod render;

use crate::fixtures::{ExtractionMethod, Fixture, InputType};
use anyhow::{Context, Result};
use camino::Utf8Path;
use itertools::Itertools;
use std::fmt::Write as _;
use std::fs;

use assertions::render_assertions;
use helpers::R_HELPERS_TEMPLATE;
use render::{
    render_config_expression, render_optional_string, render_r_string, render_string_vector, sanitize_identifier,
};

const R_TESTTHAT_BOOTSTRAP: &str = r#"library(testthat)
library(kreuzberg)

test_check("kreuzberg")
"#;

const R_DESCRIPTION_TEMPLATE: &str = r#"Package: kreuzberg.e2e
Title: Kreuzberg E2E Tests
Version: 0.0.1
Description: Auto-generated E2E tests for kreuzberg R package.
License: MIT
Suggests:
    testthat (>= 3.0.0),
    withr,
    kreuzberg
Config/testthat/edition: 3
Encoding: UTF-8
"#;

const R_LINTR_TEMPLATE: &str = r#"linters: linters_with_defaults(
    line_length_linter(120),
    object_name_linter = NULL,
    commented_code_linter = NULL
  )
exclusions: list(
    "tests/testthat/helper-kreuzberg.R"
  )
"#;

pub fn generate(fixtures: &[Fixture], output_root: &Utf8Path) -> Result<()> {
    let r_root = output_root.join("r");
    let test_dir = r_root.join("tests").join("testthat");

    fs::create_dir_all(&test_dir).context("Failed to create R test directory")?;

    // Write static files
    write_helpers(&test_dir)?;
    write_testthat_bootstrap(&r_root)?;
    write_description(&r_root)?;
    write_lintr(&r_root)?;
    clean_test_files(&test_dir)?;

    // Generate document extraction tests grouped by category
    let doc_fixtures: Vec<_> = fixtures.iter().filter(|f| f.is_document_extraction()).collect();
    let plugin_fixtures: Vec<_> = fixtures.iter().filter(|f| f.is_plugin_api()).collect();

    let mut grouped = doc_fixtures
        .into_iter()
        .into_group_map_by(|fixture| fixture.category().to_string())
        .into_iter()
        .collect::<Vec<_>>();

    grouped.sort_by(|a, b| a.0.cmp(&b.0));

    for (category, mut category_fixtures) in grouped {
        category_fixtures.sort_by(|a, b| a.id.cmp(&b.id));
        let file_name = format!("test-{}.R", sanitize_identifier(&category));
        let content = render_category(&category, &category_fixtures)?;
        let path = test_dir.join(file_name);
        fs::write(&path, content).with_context(|| format!("Writing {}", path))?;
    }

    // Generate plugin API tests
    if !plugin_fixtures.is_empty() {
        plugins::generate_plugin_api_tests(&plugin_fixtures, &test_dir)?;
    }

    Ok(())
}

fn clean_test_files(test_dir: &Utf8Path) -> Result<()> {
    if !test_dir.exists() {
        return Ok(());
    }

    for entry in fs::read_dir(test_dir.as_std_path())? {
        let entry = entry?;
        let name = entry.file_name();
        let name_str = name.to_string_lossy();
        // Keep helper files, clean generated test files
        if name_str.starts_with("helper-") {
            continue;
        }
        if entry.path().extension().is_some_and(|ext| ext == "R") {
            fs::remove_file(entry.path())?;
        }
    }

    Ok(())
}

fn write_helpers(test_dir: &Utf8Path) -> Result<()> {
    let path = test_dir.join("helper-kreuzberg.R");
    fs::write(&path, R_HELPERS_TEMPLATE).context("Failed to write R helpers")
}

fn write_testthat_bootstrap(r_root: &Utf8Path) -> Result<()> {
    let tests_dir = r_root.join("tests");
    fs::create_dir_all(&tests_dir)?;
    let path = tests_dir.join("testthat.R");
    fs::write(&path, R_TESTTHAT_BOOTSTRAP).context("Failed to write testthat.R")
}

fn write_description(r_root: &Utf8Path) -> Result<()> {
    let path = r_root.join("DESCRIPTION");
    fs::write(&path, R_DESCRIPTION_TEMPLATE).context("Failed to write DESCRIPTION")
}

fn write_lintr(r_root: &Utf8Path) -> Result<()> {
    let path = r_root.join(".lintr");
    fs::write(&path, R_LINTR_TEMPLATE).context("Failed to write .lintr")
}

fn render_category(category: &str, fixtures: &[&Fixture]) -> Result<String> {
    let mut buffer = String::new();
    writeln!(buffer, "# Code generated by kreuzberg-e2e-generator. DO NOT EDIT.")?;
    writeln!(
        buffer,
        "# To regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang r"
    )?;
    writeln!(buffer, "#")?;
    writeln!(buffer, "# Tests for {} fixtures.", category)?;
    writeln!(buffer, "# nolint start")?;
    writeln!(buffer)?;

    for (index, fixture) in fixtures.iter().enumerate() {
        let is_last = index == fixtures.len() - 1;
        buffer.push_str(&render_example(fixture, is_last)?);
    }

    writeln!(buffer, "# nolint end")?;
    Ok(buffer)
}

fn render_example(fixture: &Fixture, is_last: bool) -> Result<String> {
    let mut body = String::new();
    let extraction = fixture.extraction();
    let method = extraction.method;
    let input_type = extraction.input_type;

    let method_str = match method {
        ExtractionMethod::Sync => "\"sync\"",
        ExtractionMethod::Async => "\"async\"",
        ExtractionMethod::BatchSync => "\"batch_sync\"",
        ExtractionMethod::BatchAsync => "\"batch_async\"",
    };
    let input_type_str = match input_type {
        InputType::File => "\"file\"",
        InputType::Bytes => "\"bytes\"",
    };

    let use_simple_runner = method == ExtractionMethod::Sync && input_type == InputType::File;

    writeln!(body, "test_that({}, {{", render_r_string(&fixture.id))?;

    // Feature availability checks
    let skip_directive = fixture.skip();
    let all_features: Vec<&str> = skip_directive
        .requires_feature
        .iter()
        .chain(
            fixture
                .document()
                .requires_external_tool
                .iter()
                .filter(|t| *t == "paddle-ocr"),
        )
        .map(|s| s.as_str())
        .collect();
    for feature in &all_features {
        writeln!(body, "  skip_if_feature_unavailable({})", render_r_string(feature))?;
    }

    let config_expr = render_config_expression(&extraction.config);
    let config_str = config_expr.as_deref().unwrap_or("NULL");
    let requirements = render_string_vector(&collect_requirements(fixture));
    let notes_literal = render_optional_string(fixture.skip().notes.as_ref());
    let skip_flag = if fixture.skip().if_document_missing {
        "TRUE"
    } else {
        "FALSE"
    };

    if use_simple_runner {
        writeln!(body, "  result <- run_fixture(")?;
        writeln!(body, "    {},", render_r_string(&fixture.id))?;
        writeln!(body, "    {},", render_r_string(&fixture.document().path))?;
        writeln!(body, "    {},", config_str)?;
        writeln!(body, "    requirements = {},", requirements)?;
        writeln!(body, "    notes = {},", notes_literal)?;
        writeln!(body, "    skip_if_missing = {}", skip_flag)?;
        writeln!(body, "  )")?;
    } else {
        writeln!(body, "  result <- run_fixture_with_method(")?;
        writeln!(body, "    {},", render_r_string(&fixture.id))?;
        writeln!(body, "    {},", render_r_string(&fixture.document().path))?;
        writeln!(body, "    {},", config_str)?;
        writeln!(body, "    {},", method_str)?;
        writeln!(body, "    {},", input_type_str)?;
        writeln!(body, "    requirements = {},", requirements)?;
        writeln!(body, "    notes = {},", notes_literal)?;
        writeln!(body, "    skip_if_missing = {}", skip_flag)?;
        writeln!(body, "  )")?;
    }

    let assertion_code = render_assertions(&fixture.assertions());
    if !assertion_code.is_empty() {
        body.push_str(&assertion_code);
    }

    writeln!(body, "}})")?;
    if !is_last {
        writeln!(body)?;
    }

    Ok(body)
}

fn collect_requirements(fixture: &Fixture) -> Vec<String> {
    fixture
        .skip()
        .requires_feature
        .iter()
        .chain(fixture.document().requires_external_tool.iter())
        .filter(|value| !value.is_empty())
        .map(|value| value.to_string())
        .collect()
}
