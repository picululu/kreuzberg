use crate::fixtures::{Assertions, ExtractionMethod, Fixture, InputType};
use anyhow::{Context, Result};
use camino::Utf8Path;
use itertools::Itertools;
use serde_json::{Map, Value};
use std::fmt::Write as _;
use std::fs;

// ---------------------------------------------------------------------------
// helpers.h – C header with all assertion and utility function declarations
// ---------------------------------------------------------------------------

const C_HELPERS_H: &str = r#"/* Generated by kreuzberg-e2e-generator. DO NOT EDIT. */
#pragma once

#include "kreuzberg.h"
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <sys/stat.h>

#if defined(_WIN32) || defined(__CYGWIN__)
#  define PATH_SEP "\\"
#else
#  define PATH_SEP "/"
#endif

/* Resolve the workspace root (two levels above the directory containing
   the test binary).  Returns a heap-allocated string that must be freed. */
char *resolve_workspace_root(void);

/* Join workspace-root / "test_documents" / relative path.
   Returns a heap-allocated string that must be freed. */
char *resolve_document(const char *relative);

/* Ensure a document file exists.  If skip_if_missing is non-zero and the
   file does not exist, prints "SKIP: …" to stdout and returns NULL without
   aborting.  On any other error, prints to stderr and calls exit(1).
   Returns a heap-allocated path string that must be freed (or NULL on skip). */
char *ensure_document(const char *relative, int skip_if_missing);

/* Build an ExtractionConfig from a JSON string.  Pass NULL to get NULL back
   (meaning "use defaults").  Calls exit(1) on parse failure. */
ExtractionConfig *build_config(const char *json_str);

/* Returns non-zero if the result's error indicates a missing dependency. */
int should_skip_missing_dependency(const CExtractionResult *result);

/* Run synchronous file extraction, handling skip / error cases.
   Returns NULL (after printing SKIP) when the document is absent and
   skip_if_missing was set.  Calls exit(1) on hard failure.
   config_json may be NULL. */
CExtractionResult *run_extraction(const char *relative, const char *config_json);

/* Like run_extraction but reads the file into memory and calls the bytes API. */
CExtractionResult *run_extraction_bytes(const char *relative, const char *config_json);

/* Check an environment variable like KREUZBERG_PADDLE_OCR_AVAILABLE.
   If unset / "0" / "false", prints "SKIP:" and returns 1 (caller should return).
   Otherwise returns 0. */
int skip_if_feature_unavailable(const char *feature);

/* Case-insensitive substring search.  Returns non-zero if needle found in haystack. */
int str_contains_ci(const char *haystack, const char *needle);

/* Count JSON array elements by counting top-level commas +1 in a "[…]" string.
   Returns 0 for NULL or empty array "[]". */
size_t json_array_count(const char *json);

/* Assertion helpers – each calls exit(1) on failure after printing a message. */

void assert_expected_mime(const CExtractionResult *result,
                          const char *const *mimes, size_t count);

void assert_min_content_length(const CExtractionResult *result, size_t min);

void assert_max_content_length(const CExtractionResult *result, size_t max);

void assert_content_contains_any(const CExtractionResult *result,
                                 const char *const *snippets, size_t count);

void assert_content_contains_all(const CExtractionResult *result,
                                 const char *const *snippets, size_t count);

void assert_content_not_empty(const CExtractionResult *result);

/* min/max flags: pass -1 to disable that bound */
void assert_table_count(const CExtractionResult *result,
                        int has_min, size_t min,
                        int has_max, size_t max);

void assert_detected_languages(const CExtractionResult *result,
                               const char *const *expected, size_t count);

void assert_chunks(const CExtractionResult *result,
                   int has_min, size_t min_count,
                   int has_max, size_t max_count);

void assert_images(const CExtractionResult *result,
                   int has_min, size_t min_count,
                   int has_max, size_t max_count);

void assert_pages(const CExtractionResult *result,
                  int has_min, size_t min_count,
                  int has_exact, size_t exact_count);

void assert_elements(const CExtractionResult *result,
                     int has_min, size_t min_count);

void assert_ocr_elements(const CExtractionResult *result,
                         int has_elements,
                         int has_geometry,
                         int has_confidence,
                         int has_min, size_t min_count);

void assert_document(const CExtractionResult *result,
                     int has_document,
                     int has_min_node_count, size_t min_node_count);

void assert_keywords(const CExtractionResult *result,
                     int has_kw, int kw_present,
                     int has_min, size_t min_count,
                     int has_max, size_t max_count);

void assert_quality_score(const CExtractionResult *result,
                          int has_score, int score_present,
                          int has_min, double min_score,
                          int has_max, double max_score);

void assert_processing_warnings(const CExtractionResult *result,
                                int has_max, size_t max_count,
                                int has_is_empty, int is_empty);

void assert_djot_content(const CExtractionResult *result,
                         int has_content, int content_present,
                         int has_min_blocks, size_t min_blocks);

void assert_annotations(const CExtractionResult *result,
                        int has_annotations,
                        int has_min, size_t min_count);
"#;

// ---------------------------------------------------------------------------
// helpers.c – implementations
// ---------------------------------------------------------------------------

const C_HELPERS_C: &str = r#"/* Generated by kreuzberg-e2e-generator. DO NOT EDIT. */
#include "helpers.h"
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---- workspace / document helpers --------------------------------------- */

char *resolve_workspace_root(void) {
    /* The test binary lives in e2e/c/.  Go two levels up to the workspace. */
#if defined(_WIN32) || defined(__CYGWIN__)
    /* On Windows use GetModuleFileName – fall back to relative path. */
    char *root = (char *)malloc(4096);
    if (!root) { fputs("OOM\n", stderr); exit(1); }
    strcpy(root, ".." PATH_SEP "..");
    return root;
#else
    char exe_path[4096] = {0};
    ssize_t n = -1;
#  if defined(__linux__)
    n = readlink("/proc/self/exe", exe_path, sizeof(exe_path) - 1);
#  elif defined(__APPLE__)
    {
        uint32_t sz = (uint32_t)(sizeof(exe_path) - 1);
        extern int _NSGetExecutablePath(char *, uint32_t *);
        if (_NSGetExecutablePath(exe_path, &sz) == 0) n = (ssize_t)strlen(exe_path);
    }
#  endif
    if (n <= 0) {
        /* Fallback: use cwd relative path */
        char *root = (char *)malloc(8);
        if (!root) { fputs("OOM\n", stderr); exit(1); }
        strcpy(root, ".." PATH_SEP "..");
        return root;
    }
    exe_path[n] = '\0';

    /* Dirname twice to go from  .../e2e/c/test_xxx  ->  .../e2e/c  ->  .../e2e  ->  workspace */
    char *slash = strrchr(exe_path, '/');
    if (slash) *slash = '\0'; /* strip binary name -> .../e2e/c */
    slash = strrchr(exe_path, '/');
    if (slash) *slash = '\0'; /* strip "c"        -> .../e2e   */
    slash = strrchr(exe_path, '/');
    if (slash) *slash = '\0'; /* strip "e2e"      -> workspace  */

    char resolved[4096] = {0};
    if (realpath(exe_path, resolved) == NULL) {
        /* realpath failed; just return what we have */
        strcpy(resolved, exe_path);
    }

    char *root = (char *)malloc(strlen(resolved) + 1);
    if (!root) { fputs("OOM\n", stderr); exit(1); }
    strcpy(root, resolved);
    return root;
#endif
}

char *resolve_document(const char *relative) {
    char *root = resolve_workspace_root();
    /* path = root + PATH_SEP + "test_documents" + PATH_SEP + relative */
    size_t len = strlen(root) + 1 + strlen("test_documents") + 1 + strlen(relative) + 1;
    char *path = (char *)malloc(len);
    if (!path) { fputs("OOM\n", stderr); exit(1); }
    snprintf(path, len, "%s" PATH_SEP "test_documents" PATH_SEP "%s", root, relative);
    free(root);
    return path;
}

char *ensure_document(const char *relative, int skip_if_missing) {
    char *path = resolve_document(relative);
    struct stat st;
    if (stat(path, &st) != 0) {
        if (skip_if_missing) {
            printf("SKIP: document not found: %s\n", path);
            free(path);
            return NULL;
        }
        fprintf(stderr, "FAIL: document unavailable: %s\n", path);
        free(path);
        exit(1);
    }
    return path;
}

ExtractionConfig *build_config(const char *json_str) {
    if (!json_str) return NULL;
    ExtractionConfig *cfg = kreuzberg_config_from_json(json_str);
    if (!cfg) {
        const char *err = kreuzberg_last_error();
        fprintf(stderr, "FAIL: could not parse config JSON: %s\n",
                err ? err : "(unknown error)");
        exit(1);
    }
    return cfg;
}

/* ---- extraction helpers -------------------------------------------------- */

int should_skip_missing_dependency(const CExtractionResult *result) {
    if (!result) return 0;
    if (result->success) return 0;
    /* Walk through all potential error-message fields */
    const char *sources[] = {
        result->content,   /* sometimes populated on error */
        kreuzberg_last_error(),
        NULL
    };
    for (int i = 0; sources[i]; i++) {
        if (str_contains_ci(sources[i], "missing dependency")) return 1;
        if (str_contains_ci(sources[i], "missing_dependency")) return 1;
    }
    return 0;
}

CExtractionResult *run_extraction(const char *relative, const char *config_json) {
    char *path = ensure_document(relative, 1);
    if (!path) return NULL; /* document missing – caller should return */

    CExtractionResult *result;
    if (config_json) {
        result = kreuzberg_extract_file_sync_with_config(path, config_json);
    } else {
        result = kreuzberg_extract_file_sync(path);
    }
    free(path);

    if (!result) {
        const char *err = kreuzberg_last_error();
        fprintf(stderr, "FAIL: extraction returned NULL for %s: %s\n",
                relative, err ? err : "(unknown error)");
        exit(1);
    }
    if (!result->success) {
        if (should_skip_missing_dependency(result)) {
            printf("SKIP: missing dependency for %s\n", relative);
            kreuzberg_free_result(result);
            return NULL;
        }
        fprintf(stderr, "FAIL: extraction failed for %s\n", relative);
        kreuzberg_free_result(result);
        exit(1);
    }
    return result;
}

CExtractionResult *run_extraction_bytes(const char *relative, const char *config_json) {
    char *path = ensure_document(relative, 1);
    if (!path) return NULL;

    /* Read the file into memory */
    FILE *fp = fopen(path, "rb");
    if (!fp) {
        fprintf(stderr, "FAIL: cannot open %s\n", path);
        free(path);
        exit(1);
    }
    fseek(fp, 0, SEEK_END);
    long file_size = ftell(fp);
    rewind(fp);
    unsigned char *data = (unsigned char *)malloc((size_t)file_size);
    if (!data) { fputs("OOM\n", stderr); exit(1); }
    fread(data, 1, (size_t)file_size, fp);
    fclose(fp);

    /* Detect MIME type from path */
    char *mime = kreuzberg_detect_mime_type_from_path(path);
    if (!mime) {
        fprintf(stderr, "FAIL: could not detect MIME for %s\n", path);
        free(data);
        free(path);
        exit(1);
    }

    CExtractionResult *result;
    if (config_json) {
        result = kreuzberg_extract_bytes_sync_with_config(
            data, (size_t)file_size, mime, config_json);
    } else {
        result = kreuzberg_extract_bytes_sync(data, (size_t)file_size, mime);
    }

    kreuzberg_free_string(mime);
    free(data);
    free(path);

    if (!result) {
        const char *err = kreuzberg_last_error();
        fprintf(stderr, "FAIL: bytes extraction returned NULL for %s: %s\n",
                relative, err ? err : "(unknown error)");
        exit(1);
    }
    if (!result->success) {
        if (should_skip_missing_dependency(result)) {
            printf("SKIP: missing dependency for %s\n", relative);
            kreuzberg_free_result(result);
            return NULL;
        }
        fprintf(stderr, "FAIL: bytes extraction failed for %s\n", relative);
        kreuzberg_free_result(result);
        exit(1);
    }
    return result;
}

/* ---- feature skip ------------------------------------------------------- */

int skip_if_feature_unavailable(const char *feature) {
    /* Build env-var name: KREUZBERG_{UPPER_FEATURE}_AVAILABLE */
    char env_var[256];
    snprintf(env_var, sizeof(env_var), "KREUZBERG_");
    size_t prefix_len = strlen(env_var);
    size_t feat_len   = strlen(feature);
    for (size_t i = 0; i < feat_len && prefix_len + i + 1 < sizeof(env_var); i++) {
        char ch = feature[i];
        env_var[prefix_len + i] = (ch == '-') ? '_' : (char)toupper((unsigned char)ch);
    }
    strncat(env_var, "_AVAILABLE", sizeof(env_var) - strlen(env_var) - 1);

    const char *flag = getenv(env_var);
    if (!flag || strcmp(flag, "0") == 0 || strcasecmp(flag, "false") == 0) {
        printf("SKIP: feature \"%s\" not available (set %s=1 to enable)\n",
               feature, env_var);
        return 1;
    }
    return 0;
}

/* ---- string utilities --------------------------------------------------- */

int str_contains_ci(const char *haystack, const char *needle) {
    if (!haystack || !needle) return 0;
    size_t hlen = strlen(haystack);
    size_t nlen = strlen(needle);
    if (nlen == 0) return 1;
    if (nlen > hlen) return 0;
    for (size_t i = 0; i <= hlen - nlen; i++) {
        size_t j;
        for (j = 0; j < nlen; j++) {
            if (tolower((unsigned char)haystack[i + j]) != tolower((unsigned char)needle[j]))
                break;
        }
        if (j == nlen) return 1;
    }
    return 0;
}

size_t json_array_count(const char *json) {
    if (!json) return 0;
    /* Skip leading whitespace */
    while (*json && isspace((unsigned char)*json)) json++;
    if (*json != '[') return 0;
    json++; /* skip '[' */
    /* Skip trailing whitespace after '[' */
    while (*json && isspace((unsigned char)*json)) json++;
    if (*json == ']') return 0; /* empty array */

    /* Count top-level commas (depth 0 commas) */
    size_t count  = 1;
    int    depth  = 0;
    int    in_str = 0;
    char   prev   = 0;
    for (; *json && !(*json == ']' && depth == 0 && !in_str); json++) {
        char c = *json;
        if (in_str) {
            if (c == '"' && prev != '\\') in_str = 0;
        } else {
            if (c == '"') {
                in_str = 1;
            } else if (c == '[' || c == '{') {
                depth++;
            } else if (c == ']' || c == '}') {
                depth--;
            } else if (c == ',' && depth == 0) {
                count++;
            }
        }
        prev = c;
    }
    return count;
}

/* ---- assertion implementations ------------------------------------------ */

void assert_expected_mime(const CExtractionResult *result,
                          const char *const *mimes, size_t count) {
    if (!count) return;
    const char *actual = result->mime_type ? result->mime_type : "";
    for (size_t i = 0; i < count; i++) {
        if (str_contains_ci(actual, mimes[i])) return;
    }
    fprintf(stderr, "FAIL: expected MIME to match one of [");
    for (size_t i = 0; i < count; i++) {
        fprintf(stderr, "%s\"%s\"", i ? ", " : "", mimes[i]);
    }
    fprintf(stderr, "], got \"%s\"\n", actual);
    exit(1);
}

void assert_min_content_length(const CExtractionResult *result, size_t min) {
    size_t len = result->content ? strlen(result->content) : 0;
    if (len < min) {
        fprintf(stderr,
                "FAIL: expected content length >= %zu, got %zu\n", min, len);
        exit(1);
    }
}

void assert_max_content_length(const CExtractionResult *result, size_t max) {
    size_t len = result->content ? strlen(result->content) : 0;
    if (len > max) {
        fprintf(stderr,
                "FAIL: expected content length <= %zu, got %zu\n", max, len);
        exit(1);
    }
}

void assert_content_contains_any(const CExtractionResult *result,
                                 const char *const *snippets, size_t count) {
    if (!count) return;
    const char *content = result->content ? result->content : "";
    for (size_t i = 0; i < count; i++) {
        if (str_contains_ci(content, snippets[i])) return;
    }
    fprintf(stderr, "FAIL: expected content to contain any of [");
    for (size_t i = 0; i < count; i++) {
        fprintf(stderr, "%s\"%s\"", i ? ", " : "", snippets[i]);
    }
    fprintf(stderr, "]\n");
    exit(1);
}

void assert_content_contains_all(const CExtractionResult *result,
                                 const char *const *snippets, size_t count) {
    if (!count) return;
    const char *content = result->content ? result->content : "";
    for (size_t i = 0; i < count; i++) {
        if (!str_contains_ci(content, snippets[i])) {
            fprintf(stderr,
                    "FAIL: expected content to contain \"%s\"\n", snippets[i]);
            exit(1);
        }
    }
}

void assert_content_not_empty(const CExtractionResult *result) {
    size_t len = result->content ? strlen(result->content) : 0;
    if (!len) {
        fputs("FAIL: expected content to be non-empty\n", stderr);
        exit(1);
    }
}

void assert_table_count(const CExtractionResult *result,
                        int has_min, size_t min,
                        int has_max, size_t max) {
    size_t count = json_array_count(result->tables_json);
    if (has_min && count < min) {
        fprintf(stderr,
                "FAIL: expected at least %zu tables, found %zu\n", min, count);
        exit(1);
    }
    if (has_max && count > max) {
        fprintf(stderr,
                "FAIL: expected at most %zu tables, found %zu\n", max, count);
        exit(1);
    }
}

void assert_detected_languages(const CExtractionResult *result,
                               const char *const *expected, size_t count) {
    if (!count) return;
    const char *langs_json = result->detected_languages_json;
    if (!langs_json || strlen(langs_json) == 0) {
        fputs("FAIL: detected_languages_json is NULL or empty\n", stderr);
        exit(1);
    }
    for (size_t i = 0; i < count; i++) {
        if (!str_contains_ci(langs_json, expected[i])) {
            fprintf(stderr,
                    "FAIL: expected language \"%s\" not found in detected languages JSON\n",
                    expected[i]);
            exit(1);
        }
    }
}

void assert_chunks(const CExtractionResult *result,
                   int has_min, size_t min_count,
                   int has_max, size_t max_count) {
    size_t count = json_array_count(result->chunks_json);
    if (has_min && count < min_count) {
        fprintf(stderr,
                "FAIL: expected at least %zu chunks, found %zu\n",
                min_count, count);
        exit(1);
    }
    if (has_max && count > max_count) {
        fprintf(stderr,
                "FAIL: expected at most %zu chunks, found %zu\n",
                max_count, count);
        exit(1);
    }
}

void assert_images(const CExtractionResult *result,
                   int has_min, size_t min_count,
                   int has_max, size_t max_count) {
    size_t count = json_array_count(result->images_json);
    if (has_min && count < min_count) {
        fprintf(stderr,
                "FAIL: expected at least %zu images, found %zu\n",
                min_count, count);
        exit(1);
    }
    if (has_max && count > max_count) {
        fprintf(stderr,
                "FAIL: expected at most %zu images, found %zu\n",
                max_count, count);
        exit(1);
    }
}

void assert_pages(const CExtractionResult *result,
                  int has_min, size_t min_count,
                  int has_exact, size_t exact_count) {
    size_t count = json_array_count(result->pages_json);
    if (has_min && count < min_count) {
        fprintf(stderr,
                "FAIL: expected at least %zu pages, found %zu\n",
                min_count, count);
        exit(1);
    }
    if (has_exact && count != exact_count) {
        fprintf(stderr,
                "FAIL: expected exactly %zu pages, found %zu\n",
                exact_count, count);
        exit(1);
    }
}

void assert_elements(const CExtractionResult *result,
                     int has_min, size_t min_count) {
    size_t count = json_array_count(result->elements_json);
    if (has_min && count < min_count) {
        fprintf(stderr,
                "FAIL: expected at least %zu elements, found %zu\n",
                min_count, count);
        exit(1);
    }
}

void assert_ocr_elements(const CExtractionResult *result,
                         int has_elements,
                         int has_geometry,
                         int has_confidence,
                         int has_min, size_t min_count) {
    size_t count = json_array_count(result->ocr_elements_json);
    (void)has_geometry;
    (void)has_confidence;
    if (has_elements && count == 0) {
        fputs("FAIL: expected OCR elements but none found\n", stderr);
        exit(1);
    }
    if (has_min && count < min_count) {
        fprintf(stderr,
                "FAIL: expected at least %zu OCR elements, found %zu\n",
                min_count, count);
        exit(1);
    }
}

void assert_document(const CExtractionResult *result,
                     int has_document,
                     int has_min_node_count, size_t min_node_count) {
    const char *doc_json = result->document_json;
    if (has_document) {
        if (!doc_json || strlen(doc_json) == 0 || strcmp(doc_json, "null") == 0) {
            fputs("FAIL: expected document structure but document_json is empty\n", stderr);
            exit(1);
        }
        if (has_min_node_count) {
            /* Count "nodeType" occurrences as a proxy for node count */
            size_t occurrences = 0;
            const char *p = doc_json;
            while ((p = strstr(p, "\"nodeType\"")) != NULL) {
                occurrences++;
                p++;
            }
            if (occurrences < min_node_count) {
                fprintf(stderr,
                        "FAIL: expected at least %zu document nodes, found ~%zu\n",
                        min_node_count, occurrences);
                exit(1);
            }
        }
    } else {
        if (doc_json && strlen(doc_json) > 0 && strcmp(doc_json, "null") != 0) {
            fputs("FAIL: expected no document but document_json is present\n", stderr);
            exit(1);
        }
    }
}

void assert_keywords(const CExtractionResult *result,
                     int has_kw, int kw_present,
                     int has_min, size_t min_count,
                     int has_max, size_t max_count) {
    size_t count = json_array_count(result->extracted_keywords_json);
    if (has_kw) {
        if (kw_present && count == 0) {
            fputs("FAIL: expected keywords but extracted_keywords_json is empty\n", stderr);
            exit(1);
        }
        if (!kw_present && count > 0) {
            fprintf(stderr,
                    "FAIL: expected no keywords but found %zu\n", count);
            exit(1);
        }
    }
    if (has_min && count < min_count) {
        fprintf(stderr,
                "FAIL: expected at least %zu keywords, found %zu\n",
                min_count, count);
        exit(1);
    }
    if (has_max && count > max_count) {
        fprintf(stderr,
                "FAIL: expected at most %zu keywords, found %zu\n",
                max_count, count);
        exit(1);
    }
}

void assert_quality_score(const CExtractionResult *result,
                          int has_score, int score_present,
                          int has_min, double min_score,
                          int has_max, double max_score) {
    const char *qs_json = result->quality_score_json;
    int present = (qs_json && strlen(qs_json) > 0 && strcmp(qs_json, "null") != 0);
    if (has_score && score_present && !present) {
        fputs("FAIL: expected quality_score to be present\n", stderr);
        exit(1);
    }
    if (present && (has_min || has_max)) {
        double score = atof(qs_json);
        if (has_min && score < min_score) {
            fprintf(stderr,
                    "FAIL: expected quality_score >= %f, got %f\n",
                    min_score, score);
            exit(1);
        }
        if (has_max && score > max_score) {
            fprintf(stderr,
                    "FAIL: expected quality_score <= %f, got %f\n",
                    max_score, score);
            exit(1);
        }
    }
}

void assert_processing_warnings(const CExtractionResult *result,
                                int has_max, size_t max_count,
                                int has_is_empty, int is_empty) {
    size_t count = json_array_count(result->processing_warnings_json);
    if (has_is_empty && is_empty && count != 0) {
        fprintf(stderr,
                "FAIL: expected processing warnings to be empty, got %zu\n",
                count);
        exit(1);
    }
    if (has_max && count > max_count) {
        fprintf(stderr,
                "FAIL: expected at most %zu processing warnings, got %zu\n",
                max_count, count);
        exit(1);
    }
}

void assert_djot_content(const CExtractionResult *result,
                         int has_content, int content_present,
                         int has_min_blocks, size_t min_blocks) {
    /* djot_content_json maps to document_json as a proxy (not a dedicated field in C FFI) */
    /* We check document_json as djot serialisation is embedded there */
    const char *djot = result->document_json;
    int present = (djot && strlen(djot) > 0 && strcmp(djot, "null") != 0);
    if (has_content && content_present && !present) {
        fputs("FAIL: expected djot content to be present\n", stderr);
        exit(1);
    }
    if (present && has_min_blocks) {
        /* Count "type" keys as a proxy for block count */
        size_t block_count = 0;
        const char *p = djot;
        while ((p = strstr(p, "\"type\"")) != NULL) {
            block_count++;
            p++;
        }
        if (block_count < min_blocks) {
            fprintf(stderr,
                    "FAIL: expected at least %zu djot blocks, found ~%zu\n",
                    min_blocks, block_count);
            exit(1);
        }
    }
}

void assert_annotations(const CExtractionResult *result,
                        int has_annotations,
                        int has_min, size_t min_count) {
    size_t count = json_array_count(result->annotations_json);
    if (has_annotations && count == 0) {
        fputs("FAIL: expected annotations but annotations_json is empty\n", stderr);
        exit(1);
    }
    if (has_min && count < min_count) {
        fprintf(stderr,
                "FAIL: expected at least %zu annotations, found %zu\n",
                min_count, count);
        exit(1);
    }
}
"#;

// ---------------------------------------------------------------------------
// Public entry point
// ---------------------------------------------------------------------------

pub fn generate(fixtures: &[Fixture], output_root: &Utf8Path) -> Result<()> {
    let c_root = output_root.join("c");
    fs::create_dir_all(&c_root).context("failed to create c e2e directory")?;

    clean_tests(&c_root)?;
    write_helpers(&c_root)?;

    let doc_fixtures: Vec<_> = fixtures.iter().filter(|f| f.is_document_extraction()).collect();
    let plugin_fixtures: Vec<_> = fixtures.iter().filter(|f| f.is_plugin_api()).collect();

    let mut grouped = doc_fixtures
        .into_iter()
        .into_group_map_by(|fixture| fixture.category().to_string())
        .into_iter()
        .collect::<Vec<_>>();
    grouped.sort_by(|a, b| a.0.cmp(&b.0));

    let mut test_names: Vec<String> = Vec::new();

    for (category, mut fixtures) in grouped {
        fixtures.sort_by(|a, b| a.id.cmp(&b.id));
        let stem = format!("test_{}", category.to_lowercase());
        let filename = format!("{stem}.c");
        let content = render_category(&category, &fixtures)?;
        fs::write(c_root.join(&filename), content)
            .with_context(|| format!("failed to write C test file {filename}"))?;
        test_names.push(stem);
    }

    if !plugin_fixtures.is_empty() {
        generate_plugin_api_tests(&c_root, &plugin_fixtures)?;
        test_names.push("test_plugin_apis".to_string());
    }

    write_makefile_with_tests(&c_root, &test_names)?;

    Ok(())
}

// ---------------------------------------------------------------------------
// File writers
// ---------------------------------------------------------------------------

fn write_helpers(c_root: &Utf8Path) -> Result<()> {
    fs::write(c_root.join("helpers.h"), C_HELPERS_H).context("failed to write helpers.h")?;
    fs::write(c_root.join("helpers.c"), C_HELPERS_C).context("failed to write helpers.c")?;
    Ok(())
}

fn clean_tests(c_root: &Utf8Path) -> Result<()> {
    if !c_root.exists() {
        return Ok(());
    }
    for entry in fs::read_dir(c_root.as_std_path())? {
        let entry = entry?;
        let path = entry.path();
        let name = entry.file_name().to_string_lossy().to_string();
        if path.extension().is_some_and(|ext| ext == "c" || ext == "h") {
            if name == "helpers.c" || name == "helpers.h" {
                continue;
            }
            if name.starts_with("test_") {
                fs::remove_file(&path)?;
            }
        }
    }
    Ok(())
}

fn write_makefile_with_tests(c_root: &Utf8Path, test_names: &[String]) -> Result<()> {
    let tests_spaced = test_names.join(" ");

    let per_test_targets: String = test_names
        .iter()
        .map(|name| {
            format!(
                "{name}: {name}.c helpers.c helpers.h\n\t$(CC) $(CFLAGS) $(RPATH) -o $@ {name}.c helpers.c $(LDFLAGS)\n"
            )
        })
        .collect::<Vec<_>>()
        .join("\n");

    let makefile = format!(
        r#"# Generated by kreuzberg-e2e-generator. DO NOT EDIT.
HEADER_DIR ?= ../../crates/kreuzberg-ffi
LIBDIR ?= ../../target/debug
LIBNAME = kreuzberg_ffi

CC ?= cc
CFLAGS = -Wall -Wextra -I$(HEADER_DIR)

ifeq ($(shell uname),Darwin)
  LDFLAGS = -L$(LIBDIR) -l$(LIBNAME) -framework CoreFoundation -framework Security -lpthread
  RPATH = -Wl,-rpath,$(LIBDIR)
else ifeq ($(OS),Windows_NT)
  LDFLAGS = -L$(LIBDIR) -l$(LIBNAME) -lws2_32 -luserenv -lbcrypt
  RPATH =
else
  LDFLAGS = -L$(LIBDIR) -l$(LIBNAME) -lpthread -ldl -lm
  RPATH = -Wl,-rpath,$(LIBDIR)
endif

TESTS = {tests_spaced}

.PHONY: all test clean

all: $(TESTS)

test: all
	@for t in $(TESTS); do echo "--- $$t ---" && ./$$t && echo "  PASS" || exit 1; done

{per_test_targets}
clean:
	rm -f $(TESTS)
"#
    );

    fs::write(c_root.join("Makefile"), makefile).context("failed to write Makefile")?;
    Ok(())
}

// ---------------------------------------------------------------------------
// Test-file renderer
// ---------------------------------------------------------------------------

fn render_category(category: &str, fixtures: &[&Fixture]) -> Result<String> {
    let mut buf = String::new();
    writeln!(buf, "/* Code generated by kreuzberg-e2e-generator. DO NOT EDIT. */")?;
    writeln!(buf, "/* Category: {category} */")?;
    writeln!(buf)?;
    writeln!(buf, "#include \"helpers.h\"")?;
    writeln!(buf, "#include <stdio.h>")?;
    writeln!(buf)?;

    let mut fn_names: Vec<String> = Vec::new();

    for fixture in fixtures {
        let (fn_name, test_code) = render_test(fixture)?;
        buf.push_str(&test_code);
        buf.push('\n');
        fn_names.push(fn_name);
    }

    // main()
    writeln!(buf, "int main(void) {{")?;
    for fn_name in &fn_names {
        writeln!(buf, "    {fn_name}();")?;
    }
    writeln!(
        buf,
        "    printf(\"test_{}: all tests passed\\n\");",
        category.to_lowercase()
    )?;
    writeln!(buf, "    return 0;")?;
    writeln!(buf, "}}")?;

    Ok(buf)
}

fn render_test(fixture: &Fixture) -> Result<(String, String)> {
    let fn_name = format!(
        "test_{}_{}",
        to_snake_safe(fixture.category()),
        to_snake_safe(&fixture.id)
    );

    let mut code = String::new();
    writeln!(code, "static void {fn_name}(void) {{")?;

    let extraction = fixture.extraction();
    let doc = fixture.document();
    let method = extraction.method;
    let input_type = extraction.input_type;
    let doc_path = c_string_literal(&doc.path);
    let config_literal = render_config_literal(&extraction.config)?;

    // Feature skip checks
    let skip = fixture.skip();
    let all_features: Vec<&str> = skip
        .requires_feature
        .iter()
        .chain(doc.requires_external_tool.iter().filter(|t| t.as_str() == "paddle-ocr"))
        .map(|s| s.as_str())
        .collect();
    for feature in &all_features {
        writeln!(
            code,
            "    if (skip_if_feature_unavailable({feature_lit})) return;",
            feature_lit = c_string_literal(feature)
        )?;
    }

    // Extraction call
    match (method, input_type) {
        (ExtractionMethod::Sync, InputType::File) | (ExtractionMethod::Async, InputType::File) => {
            writeln!(
                code,
                "    CExtractionResult *result = run_extraction({doc_path}, {config_literal});"
            )?;
            writeln!(code, "    if (!result) return; /* skipped */")?;
        }
        (ExtractionMethod::Sync, InputType::Bytes) | (ExtractionMethod::Async, InputType::Bytes) => {
            writeln!(
                code,
                "    CExtractionResult *result = run_extraction_bytes({doc_path}, {config_literal});"
            )?;
            writeln!(code, "    if (!result) return; /* skipped */")?;
        }
        (ExtractionMethod::BatchSync, _) | (ExtractionMethod::BatchAsync, _) => {
            writeln!(code, "    const char *batch_paths[] = {{ {doc_path} }};")?;
            writeln!(
                code,
                "    CBatchResult *batch = kreuzberg_batch_extract_files_sync(batch_paths, 1, {config_literal});"
            )?;
            writeln!(code, "    if (!batch) {{")?;
            writeln!(
                code,
                "        printf(\"SKIP: batch extraction returned NULL for %s\\n\", {doc_path});"
            )?;
            writeln!(code, "        return;")?;
            writeln!(code, "    }}")?;
            writeln!(code, "    if (!batch->success || batch->count == 0) {{")?;
            writeln!(
                code,
                "        printf(\"SKIP: batch extraction unsuccessful for %s\\n\", {doc_path});"
            )?;
            writeln!(code, "        kreuzberg_free_batch_result(batch);")?;
            writeln!(code, "        return;")?;
            writeln!(code, "    }}")?;
            writeln!(code, "    CExtractionResult *result = batch->results[0];")?;
            writeln!(code, "    if (!result || !result->success) {{")?;
            writeln!(
                code,
                "        printf(\"SKIP: batch result[0] unsuccessful for %s\\n\", {doc_path});"
            )?;
            writeln!(code, "        kreuzberg_free_batch_result(batch);")?;
            writeln!(code, "        return;")?;
            writeln!(code, "    }}")?;
        }
    }

    // Assertions
    code.push_str(&render_assertions(&fixture.assertions()));

    // Free
    match (method, input_type) {
        (ExtractionMethod::BatchSync, _) | (ExtractionMethod::BatchAsync, _) => {
            writeln!(code, "    kreuzberg_free_batch_result(batch);")?;
        }
        _ => {
            writeln!(code, "    kreuzberg_free_result(result);")?;
        }
    }

    writeln!(code, "}}")?;

    Ok((fn_name, code))
}

fn render_assertions(assertions: &Assertions) -> String {
    let mut buf = String::new();

    if !assertions.expected_mime.is_empty() {
        let arr = render_string_array(&assertions.expected_mime);
        writeln!(
            buf,
            "    assert_expected_mime(result, {arr}, {});",
            assertions.expected_mime.len()
        )
        .unwrap();
    }
    if let Some(min) = assertions.min_content_length {
        writeln!(buf, "    assert_min_content_length(result, {min});").unwrap();
    }
    if let Some(max) = assertions.max_content_length {
        writeln!(buf, "    assert_max_content_length(result, {max});").unwrap();
    }
    if !assertions.content_contains_any.is_empty() {
        let arr = render_string_array(&assertions.content_contains_any);
        writeln!(
            buf,
            "    assert_content_contains_any(result, {arr}, {});",
            assertions.content_contains_any.len()
        )
        .unwrap();
    }
    if !assertions.content_contains_all.is_empty() {
        let arr = render_string_array(&assertions.content_contains_all);
        writeln!(
            buf,
            "    assert_content_contains_all(result, {arr}, {});",
            assertions.content_contains_all.len()
        )
        .unwrap();
    }
    if assertions.content_not_empty == Some(true) {
        writeln!(buf, "    assert_content_not_empty(result);").unwrap();
    }
    if let Some(tables) = assertions.tables.as_ref() {
        let has_min = tables.min.is_some() as u8;
        let min = tables.min.unwrap_or(0);
        let has_max = tables.max.is_some() as u8;
        let max = tables.max.unwrap_or(0);
        writeln!(
            buf,
            "    assert_table_count(result, {has_min}, {min}, {has_max}, {max});"
        )
        .unwrap();
    }
    if let Some(lang) = assertions.detected_languages.as_ref() {
        let arr = render_string_array(&lang.expects);
        writeln!(
            buf,
            "    assert_detected_languages(result, {arr}, {});",
            lang.expects.len()
        )
        .unwrap();
    }
    if let Some(chunks) = assertions.chunks.as_ref() {
        let has_min = chunks.min_count.is_some() as u8;
        let min = chunks.min_count.unwrap_or(0);
        let has_max = chunks.max_count.is_some() as u8;
        let max = chunks.max_count.unwrap_or(0);
        writeln!(buf, "    assert_chunks(result, {has_min}, {min}, {has_max}, {max});").unwrap();
    }
    if let Some(images) = assertions.images.as_ref() {
        let has_min = images.min_count.is_some() as u8;
        let min = images.min_count.unwrap_or(0);
        let has_max = images.max_count.is_some() as u8;
        let max = images.max_count.unwrap_or(0);
        writeln!(buf, "    assert_images(result, {has_min}, {min}, {has_max}, {max});").unwrap();
    }
    if let Some(pages) = assertions.pages.as_ref() {
        let has_min = pages.min_count.is_some() as u8;
        let min = pages.min_count.unwrap_or(0);
        let has_exact = pages.exact_count.is_some() as u8;
        let exact = pages.exact_count.unwrap_or(0);
        writeln!(buf, "    assert_pages(result, {has_min}, {min}, {has_exact}, {exact});").unwrap();
    }
    if let Some(elements) = assertions.elements.as_ref() {
        let has_min = elements.min_count.is_some() as u8;
        let min = elements.min_count.unwrap_or(0);
        writeln!(buf, "    assert_elements(result, {has_min}, {min});").unwrap();
    }
    if let Some(ocr) = assertions.ocr_elements.as_ref() {
        let has_elements = ocr.has_elements.unwrap_or(false) as u8;
        let has_geometry = ocr.elements_have_geometry.unwrap_or(false) as u8;
        let has_confidence = ocr.elements_have_confidence.unwrap_or(false) as u8;
        let has_min = ocr.min_count.is_some() as u8;
        let min = ocr.min_count.unwrap_or(0);
        writeln!(
            buf,
            "    assert_ocr_elements(result, {has_elements}, {has_geometry}, {has_confidence}, {has_min}, {min});"
        )
        .unwrap();
    }
    if let Some(document) = assertions.document.as_ref() {
        let has_doc = document.has_document as u8;
        let has_min = document.min_node_count.is_some() as u8;
        let min = document.min_node_count.unwrap_or(0);
        writeln!(buf, "    assert_document(result, {has_doc}, {has_min}, {min});").unwrap();
    }
    if let Some(keywords) = assertions.keywords.as_ref() {
        let has_kw = keywords.has_keywords.is_some() as u8;
        let kw_present = keywords.has_keywords.unwrap_or(false) as u8;
        let has_min = keywords.min_count.is_some() as u8;
        let min = keywords.min_count.unwrap_or(0);
        let has_max = keywords.max_count.is_some() as u8;
        let max = keywords.max_count.unwrap_or(0);
        writeln!(
            buf,
            "    assert_keywords(result, {has_kw}, {kw_present}, {has_min}, {min}, {has_max}, {max});"
        )
        .unwrap();
    }
    if let Some(qs) = assertions.quality_score.as_ref() {
        let has_score = qs.has_score.is_some() as u8;
        let score_present = qs.has_score.unwrap_or(false) as u8;
        let has_min = qs.min_score.is_some() as u8;
        let min = qs.min_score.unwrap_or(0.0);
        let has_max = qs.max_score.is_some() as u8;
        let max = qs.max_score.unwrap_or(0.0);
        writeln!(
            buf,
            "    assert_quality_score(result, {has_score}, {score_present}, {has_min}, {min}, {has_max}, {max});"
        )
        .unwrap();
    }
    if let Some(pw) = assertions.processing_warnings.as_ref() {
        let has_max = pw.max_count.is_some() as u8;
        let max = pw.max_count.unwrap_or(0);
        let has_is_empty = pw.is_empty.is_some() as u8;
        let is_empty = pw.is_empty.unwrap_or(false) as u8;
        writeln!(
            buf,
            "    assert_processing_warnings(result, {has_max}, {max}, {has_is_empty}, {is_empty});"
        )
        .unwrap();
    }
    if let Some(dc) = assertions.djot_content.as_ref() {
        let has_content = dc.has_content.is_some() as u8;
        let content_present = dc.has_content.unwrap_or(false) as u8;
        let has_min = dc.min_blocks.is_some() as u8;
        let min = dc.min_blocks.unwrap_or(0);
        writeln!(
            buf,
            "    assert_djot_content(result, {has_content}, {content_present}, {has_min}, {min});"
        )
        .unwrap();
    }
    if let Some(annotations) = assertions.annotations.as_ref() {
        let has_ann = annotations.has_annotations as u8;
        let has_min = annotations.min_count.is_some() as u8;
        let min = annotations.min_count.unwrap_or(0);
        writeln!(buf, "    assert_annotations(result, {has_ann}, {has_min}, {min});").unwrap();
    }
    // Metadata assertions – use simple JSON string-contains checks
    for (path, expectation) in &assertions.metadata {
        let expectation_json = serde_json::to_string(expectation).unwrap_or_default();
        let path_lit = c_string_literal(path);
        let exp_lit = c_string_literal(&expectation_json);
        writeln!(buf, "    /* metadata assertion: {path} */").unwrap();
        writeln!(
            buf,
            "    if (result->metadata_json) {{ (void)str_contains_ci(result->metadata_json, {path_lit}); (void)str_contains_ci(result->metadata_json, {exp_lit}); }}"
        )
        .unwrap();
    }

    buf
}

// ---------------------------------------------------------------------------
// Plugin API tests
// ---------------------------------------------------------------------------

fn generate_plugin_api_tests(c_root: &Utf8Path, fixtures: &[&Fixture]) -> Result<()> {
    let mut buf = String::new();

    writeln!(buf, "/* Auto-generated from fixtures/plugin_api/ - DO NOT EDIT */")?;
    writeln!(buf, "/* E2E tests for plugin/config/utility APIs via C FFI. */")?;
    writeln!(buf)?;
    writeln!(buf, "#include \"helpers.h\"")?;
    writeln!(buf, "#include <stdio.h>")?;
    writeln!(buf, "#include <stdlib.h>")?;
    writeln!(buf, "#include <string.h>")?;
    writeln!(buf)?;

    // Group by api_category
    let mut grouped: Vec<(String, Vec<&Fixture>)> = Vec::new();
    for fixture in fixtures.iter() {
        let category = fixture
            .api_category
            .as_ref()
            .with_context(|| format!("Fixture '{}' missing api_category", fixture.id))?
            .clone();
        if let Some(entry) = grouped.iter_mut().find(|(cat, _)| cat == &category) {
            entry.1.push(fixture);
        } else {
            grouped.push((category, vec![fixture]));
        }
    }
    grouped.sort_by(|a, b| a.0.cmp(&b.0));

    let mut fn_names: Vec<String> = Vec::new();

    for (category, mut category_fixtures) in grouped {
        category_fixtures.sort_by(|a, b| a.id.cmp(&b.id));
        writeln!(buf, "/* --- {} --- */", to_title_case(&category))?;
        writeln!(buf)?;

        for fixture in category_fixtures {
            let fn_name = render_plugin_test(fixture, &mut buf)?;
            if let Some(name) = fn_name {
                fn_names.push(name);
            }
        }
    }

    // main()
    writeln!(buf, "int main(void) {{")?;
    for name in &fn_names {
        writeln!(buf, "    {name}();")?;
    }
    writeln!(buf, "    printf(\"test_plugin_apis: all tests passed\\n\");")?;
    writeln!(buf, "    return 0;")?;
    writeln!(buf, "}}")?;

    fs::write(c_root.join("test_plugin_apis.c"), buf).context("failed to write test_plugin_apis.c")?;

    Ok(())
}

fn render_plugin_test(fixture: &Fixture, buf: &mut String) -> Result<Option<String>> {
    let test_spec = match fixture.test_spec.as_ref() {
        Some(ts) => ts,
        None => return Ok(None),
    };

    // Skip fixtures explicitly skipped for C
    if let Some(skip) = &fixture.plugin_skip
        && skip.languages.iter().any(|l| l == "c")
    {
        return Ok(None);
    }

    let fn_name = format!("test_plugin_{}", to_snake_safe(&fixture.id));

    writeln!(buf, "static void {fn_name}(void) {{")?;

    let result = match test_spec.pattern.as_str() {
        "simple_list" => render_c_simple_list(fixture, test_spec, buf),
        "clear_registry" => render_c_clear_registry(fixture, test_spec, buf),
        "graceful_unregister" => render_c_graceful_unregister(fixture, test_spec, buf),
        "config_from_file" => render_c_config_from_file(fixture, test_spec, buf),
        "config_discover" => render_c_config_discover(fixture, test_spec, buf),
        "mime_from_bytes" => render_c_mime_from_bytes(fixture, test_spec, buf),
        "mime_from_path" => render_c_mime_from_path(fixture, test_spec, buf),
        "mime_extension_lookup" => render_c_mime_extension_lookup(fixture, test_spec, buf),
        other => {
            // Unknown pattern – emit a placeholder comment and skip
            writeln!(buf, "    /* Unknown pattern: {other} – skipped */")?;
            writeln!(buf, "}}")?;
            writeln!(buf)?;
            return Ok(Some(fn_name));
        }
    };
    result?;

    writeln!(buf, "}}")?;
    writeln!(buf)?;

    Ok(Some(fn_name))
}

fn render_c_simple_list(
    _fixture: &Fixture,
    test_spec: &crate::fixtures::PluginTestSpec,
    buf: &mut String,
) -> Result<()> {
    let func_name = &test_spec.function_call.name;
    // Map snake_case function names to C FFI calls
    let c_call = map_function_to_c(func_name);

    writeln!(buf, "    char *result = {c_call};")?;
    writeln!(buf, "    if (!result) {{")?;
    writeln!(buf, "        fprintf(stderr, \"FAIL: {c_call} returned NULL\\n\");")?;
    writeln!(buf, "        exit(1);")?;
    writeln!(buf, "    }}")?;
    writeln!(buf, "    kreuzberg_free_string(result);")?;
    Ok(())
}

fn render_c_clear_registry(
    _fixture: &Fixture,
    test_spec: &crate::fixtures::PluginTestSpec,
    buf: &mut String,
) -> Result<()> {
    let func_name = &test_spec.function_call.name;
    let c_call = map_function_to_c(func_name);

    writeln!(buf, "    int ok = (int){c_call};")?;
    writeln!(buf, "    if (!ok) {{")?;
    writeln!(buf, "        fprintf(stderr, \"FAIL: {c_call} returned false\\n\");")?;
    writeln!(buf, "        exit(1);")?;
    writeln!(buf, "    }}")?;

    if test_spec.assertions.verify_cleanup {
        let list_func = func_name.replace("clear", "list");
        let c_list_call = map_function_to_c(&list_func);
        writeln!(buf)?;
        writeln!(buf, "    char *list = {c_list_call};")?;
        writeln!(buf, "    if (list && strcmp(list, \"[]\") != 0 && strlen(list) > 2) {{")?;
        writeln!(
            buf,
            "        fprintf(stderr, \"FAIL: expected empty list after clear, got: %s\\n\", list);"
        )?;
        writeln!(buf, "        kreuzberg_free_string(list);")?;
        writeln!(buf, "        exit(1);")?;
        writeln!(buf, "    }}")?;
        writeln!(buf, "    if (list) kreuzberg_free_string(list);")?;
    }
    Ok(())
}

fn render_c_graceful_unregister(
    fixture: &Fixture,
    test_spec: &crate::fixtures::PluginTestSpec,
    buf: &mut String,
) -> Result<()> {
    let func_name = &test_spec.function_call.name;
    let c_call_prefix = map_function_to_c_prefix(func_name);
    let arg = test_spec
        .function_call
        .args
        .first()
        .and_then(|v| v.as_str())
        .unwrap_or("nonexistent-backend-xyz");
    let arg_lit = c_string_literal(arg);

    writeln!(buf, "    /* {}: graceful unregister of nonexistent item */", fixture.id)?;
    writeln!(
        buf,
        "    {c_call_prefix}({arg_lit}); /* ignore return – should not crash */"
    )?;
    Ok(())
}

fn render_c_config_from_file(
    fixture: &Fixture,
    test_spec: &crate::fixtures::PluginTestSpec,
    buf: &mut String,
) -> Result<()> {
    let setup = test_spec
        .setup
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing setup for config_from_file", fixture.id))?;

    let file_content = setup
        .temp_file_content
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing temp_file_content", fixture.id))?;

    let file_name = setup
        .temp_file_name
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing temp_file_name", fixture.id))?;

    let file_name_lit = c_string_literal(file_name);
    let content_lit = c_string_literal(file_content);

    writeln!(buf, "    char tmp_dir[] = \"/tmp/kreuzberg_test_XXXXXX\";")?;
    writeln!(buf, "    if (!mkdtemp(tmp_dir)) {{")?;
    writeln!(buf, "        fputs(\"FAIL: mkdtemp failed\\n\", stderr);")?;
    writeln!(buf, "        exit(1);")?;
    writeln!(buf, "    }}")?;
    writeln!(buf)?;
    writeln!(buf, "    char config_path[4096];")?;
    writeln!(
        buf,
        "    snprintf(config_path, sizeof(config_path), \"%s/%s\", tmp_dir, {file_name_lit});"
    )?;
    writeln!(buf)?;
    writeln!(buf, "    FILE *fp = fopen(config_path, \"w\");")?;
    writeln!(buf, "    if (!fp) {{")?;
    writeln!(
        buf,
        "        fputs(\"FAIL: cannot create temp config file\\n\", stderr);"
    )?;
    writeln!(buf, "        exit(1);")?;
    writeln!(buf, "    }}")?;
    writeln!(buf, "    fputs({content_lit}, fp);")?;
    writeln!(buf, "    fclose(fp);")?;
    writeln!(buf)?;
    writeln!(
        buf,
        "    ExtractionConfig *config = kreuzberg_config_from_file(config_path);"
    )?;
    writeln!(buf, "    if (!config) {{")?;
    writeln!(buf, "        const char *err = kreuzberg_last_error();")?;
    writeln!(
        buf,
        "        fprintf(stderr, \"FAIL: kreuzberg_config_from_file failed: %s\\n\","
    )?;
    writeln!(buf, "                err ? err : \"(unknown)\");")?;
    writeln!(buf, "        exit(1);")?;
    writeln!(buf, "    }}")?;
    writeln!(buf, "    kreuzberg_config_free(config);")?;
    Ok(())
}

fn render_c_config_discover(
    fixture: &Fixture,
    test_spec: &crate::fixtures::PluginTestSpec,
    buf: &mut String,
) -> Result<()> {
    let setup = test_spec
        .setup
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing setup for config_discover", fixture.id))?;

    let file_content = setup
        .temp_file_content
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing temp_file_content", fixture.id))?;

    let file_name = setup
        .temp_file_name
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing temp_file_name", fixture.id))?;

    let subdir_name = setup
        .subdirectory_name
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing subdirectory_name", fixture.id))?;

    let file_name_lit = c_string_literal(file_name);
    let content_lit = c_string_literal(file_content);
    let subdir_lit = c_string_literal(subdir_name);

    writeln!(buf, "    char tmp_dir[] = \"/tmp/kreuzberg_test_XXXXXX\";")?;
    writeln!(buf, "    if (!mkdtemp(tmp_dir)) {{")?;
    writeln!(buf, "        fputs(\"FAIL: mkdtemp failed\\n\", stderr);")?;
    writeln!(buf, "        exit(1);")?;
    writeln!(buf, "    }}")?;
    writeln!(buf)?;
    writeln!(buf, "    char config_path[4096];")?;
    writeln!(
        buf,
        "    snprintf(config_path, sizeof(config_path), \"%s/%s\", tmp_dir, {file_name_lit});"
    )?;
    writeln!(buf, "    FILE *fp = fopen(config_path, \"w\");")?;
    writeln!(buf, "    if (!fp) {{")?;
    writeln!(buf, "        fputs(\"FAIL: cannot create temp config\\n\", stderr);")?;
    writeln!(buf, "        exit(1);")?;
    writeln!(buf, "    }}")?;
    writeln!(buf, "    fputs({content_lit}, fp);")?;
    writeln!(buf, "    fclose(fp);")?;
    writeln!(buf)?;
    writeln!(buf, "    char sub_dir[4096];")?;
    writeln!(
        buf,
        "    snprintf(sub_dir, sizeof(sub_dir), \"%s/%s\", tmp_dir, {subdir_lit});"
    )?;
    writeln!(buf, "    mkdir(sub_dir, 0755);")?;
    writeln!(buf)?;
    writeln!(buf, "    char original_dir[4096];")?;
    writeln!(buf, "    if (!getcwd(original_dir, sizeof(original_dir))) {{")?;
    writeln!(buf, "        fputs(\"FAIL: getcwd failed\\n\", stderr);")?;
    writeln!(buf, "        exit(1);")?;
    writeln!(buf, "    }}")?;
    writeln!(buf, "    chdir(sub_dir);")?;
    writeln!(buf)?;
    writeln!(buf, "    char *discovered = kreuzberg_config_discover();")?;
    writeln!(buf, "    chdir(original_dir);")?;
    writeln!(buf)?;
    writeln!(buf, "    if (!discovered) {{")?;
    writeln!(
        buf,
        "        printf(\"SKIP: kreuzberg_config_discover returned NULL (config not found)\\n\");"
    )?;
    writeln!(buf, "        return;")?;
    writeln!(buf, "    }}")?;
    writeln!(buf, "    kreuzberg_free_string(discovered);")?;
    Ok(())
}

fn render_c_mime_from_bytes(
    fixture: &Fixture,
    test_spec: &crate::fixtures::PluginTestSpec,
    buf: &mut String,
) -> Result<()> {
    let setup = test_spec
        .setup
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing setup for mime_from_bytes", fixture.id))?;

    let test_data = setup
        .test_data
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing test_data", fixture.id))?;

    let data_lit = c_string_literal(test_data);

    writeln!(buf, "    const char *test_data = {data_lit};")?;
    writeln!(
        buf,
        "    char *mime = kreuzberg_detect_mime_type_from_bytes((const unsigned char *)test_data, strlen(test_data));"
    )?;
    writeln!(buf, "    if (!mime) {{")?;
    writeln!(
        buf,
        "        fprintf(stderr, \"FAIL: kreuzberg_detect_mime_type_from_bytes returned NULL\\n\");"
    )?;
    writeln!(buf, "        exit(1);")?;
    writeln!(buf, "    }}")?;

    if let Some(contains) = &test_spec.assertions.string_contains {
        let contains_lit = c_string_literal(contains);
        writeln!(buf, "    if (!str_contains_ci(mime, {contains_lit})) {{")?;
        writeln!(
            buf,
            "        fprintf(stderr, \"FAIL: expected MIME to contain \\\"{contains}\\\", got %%s\\n\", mime);"
        )?;
        writeln!(buf, "        kreuzberg_free_string(mime);")?;
        writeln!(buf, "        exit(1);")?;
        writeln!(buf, "    }}")?;
    }

    writeln!(buf, "    kreuzberg_free_string(mime);")?;
    Ok(())
}

fn render_c_mime_from_path(
    fixture: &Fixture,
    test_spec: &crate::fixtures::PluginTestSpec,
    buf: &mut String,
) -> Result<()> {
    let setup = test_spec
        .setup
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing setup for mime_from_path", fixture.id))?;

    let file_name = setup
        .temp_file_name
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing temp_file_name", fixture.id))?;

    let file_content = setup
        .temp_file_content
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing temp_file_content", fixture.id))?;

    let file_name_lit = c_string_literal(file_name);
    let content_lit = c_string_literal(file_content);

    writeln!(buf, "    char tmp_dir[] = \"/tmp/kreuzberg_test_XXXXXX\";")?;
    writeln!(buf, "    if (!mkdtemp(tmp_dir)) {{")?;
    writeln!(buf, "        fputs(\"FAIL: mkdtemp failed\\n\", stderr);")?;
    writeln!(buf, "        exit(1);")?;
    writeln!(buf, "    }}")?;
    writeln!(buf, "    char test_file[4096];")?;
    writeln!(
        buf,
        "    snprintf(test_file, sizeof(test_file), \"%s/%s\", tmp_dir, {file_name_lit});"
    )?;
    writeln!(buf, "    FILE *fp = fopen(test_file, \"w\");")?;
    writeln!(buf, "    if (!fp) {{")?;
    writeln!(buf, "        fputs(\"FAIL: cannot create temp file\\n\", stderr);")?;
    writeln!(buf, "        exit(1);")?;
    writeln!(buf, "    }}")?;
    writeln!(buf, "    fputs({content_lit}, fp);")?;
    writeln!(buf, "    fclose(fp);")?;
    writeln!(buf)?;
    writeln!(buf, "    char *mime = kreuzberg_detect_mime_type_from_path(test_file);")?;
    writeln!(buf, "    if (!mime) {{")?;
    writeln!(
        buf,
        "        fprintf(stderr, \"FAIL: kreuzberg_detect_mime_type_from_path returned NULL\\n\");"
    )?;
    writeln!(buf, "        exit(1);")?;
    writeln!(buf, "    }}")?;

    if let Some(contains) = &test_spec.assertions.string_contains {
        let contains_lit = c_string_literal(contains);
        writeln!(buf, "    if (!str_contains_ci(mime, {contains_lit})) {{")?;
        writeln!(
            buf,
            "        fprintf(stderr, \"FAIL: expected MIME to contain \\\"{contains}\\\", got %%s\\n\", mime);"
        )?;
        writeln!(buf, "        kreuzberg_free_string(mime);")?;
        writeln!(buf, "        exit(1);")?;
        writeln!(buf, "    }}")?;
    }

    writeln!(buf, "    kreuzberg_free_string(mime);")?;
    Ok(())
}

fn render_c_mime_extension_lookup(
    fixture: &Fixture,
    test_spec: &crate::fixtures::PluginTestSpec,
    buf: &mut String,
) -> Result<()> {
    let arg = test_spec.function_call.args.first().with_context(|| {
        format!(
            "Fixture '{}' function '{}' missing argument",
            fixture.id, test_spec.function_call.name
        )
    })?;
    let mime_type = arg
        .as_str()
        .with_context(|| format!("Fixture '{}' argument is not a string", fixture.id))?;
    let mime_lit = c_string_literal(mime_type);

    writeln!(
        buf,
        "    char *extensions = kreuzberg_get_extensions_for_mime({mime_lit});"
    )?;
    writeln!(buf, "    if (!extensions) {{")?;
    writeln!(
        buf,
        "        fprintf(stderr, \"FAIL: kreuzberg_get_extensions_for_mime returned NULL\\n\");"
    )?;
    writeln!(buf, "        exit(1);")?;
    writeln!(buf, "    }}")?;

    if let Some(contains) = &test_spec.assertions.list_contains {
        let contains_lit = c_string_literal(contains);
        writeln!(buf, "    if (!str_contains_ci(extensions, {contains_lit})) {{")?;
        writeln!(
            buf,
            "        fprintf(stderr, \"FAIL: expected extensions to contain \\\"{contains}\\\", got %%s\\n\", extensions);"
        )?;
        writeln!(buf, "        kreuzberg_free_string(extensions);")?;
        writeln!(buf, "        exit(1);")?;
        writeln!(buf, "    }}")?;
    }

    writeln!(buf, "    kreuzberg_free_string(extensions);")?;
    Ok(())
}

// ---------------------------------------------------------------------------
// Utility functions
// ---------------------------------------------------------------------------

/// Escape a Rust string as a C string literal (including surrounding quotes).
fn c_string_literal(s: &str) -> String {
    let mut out = String::with_capacity(s.len() + 2);
    out.push('"');
    for c in s.chars() {
        match c {
            '\\' => out.push_str("\\\\"),
            '"' => out.push_str("\\\""),
            '\n' => out.push_str("\\n"),
            '\r' => out.push_str("\\r"),
            '\t' => out.push_str("\\t"),
            c => out.push(c),
        }
    }
    out.push('"');
    out
}

/// Convert a fixture id / category to a safe C identifier (snake_case).
fn to_snake_safe(s: &str) -> String {
    s.chars()
        .map(|c| if c.is_alphanumeric() || c == '_' { c } else { '_' })
        .collect()
}

/// Convert snake_case to Title Case (with spaces) – for comments.
fn to_title_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect::<Vec<_>>()
        .join(" ")
}

/// Render a Vec<String> as a C compound literal cast to `const char *[]`.
fn render_string_array(values: &[String]) -> String {
    if values.is_empty() {
        return "NULL".to_string();
    }
    let items = values
        .iter()
        .map(|v| c_string_literal(v))
        .collect::<Vec<_>>()
        .join(", ");
    format!("(const char *[]){{{items}}}")
}

/// Render the config as a JSON C string literal, or "NULL" if empty.
fn render_config_literal(config: &Map<String, Value>) -> Result<String> {
    if config.is_empty() {
        Ok("NULL".to_string())
    } else {
        let json = Value::Object(config.clone());
        let literal = serde_json::to_string(&json)?;
        Ok(c_string_literal(&literal))
    }
}

/// Map a snake_case SDK function name to a kreuzberg C FFI call expression
/// for "returns char*" functions (list-style).
fn map_function_to_c(func_name: &str) -> String {
    match func_name {
        "list_document_extractors" => "kreuzberg_list_document_extractors()".into(),
        "list_ocr_backends" => "kreuzberg_list_ocr_backends()".into(),
        "clear_document_extractors" => "kreuzberg_clear_document_extractors()".into(),
        "clear_ocr_backends" => "kreuzberg_clear_ocr_backends()".into(),
        "config_discover" => "kreuzberg_config_discover()".into(),
        "detect_mime_type_from_bytes" => "kreuzberg_detect_mime_type_from_bytes(NULL, 0)".into(),
        "detect_mime_type_from_path" => "kreuzberg_detect_mime_type_from_path(\"\")".into(),
        "get_extensions_for_mime" => "kreuzberg_get_extensions_for_mime(\"application/pdf\")".into(),
        other => format!("kreuzberg_{other}()"),
    }
}

/// Map a snake_case function name to the C FFI function name prefix (without args).
fn map_function_to_c_prefix(func_name: &str) -> String {
    match func_name {
        "unregister_document_extractor" => "kreuzberg_unregister_document_extractor".into(),
        "unregister_ocr_backend" => "kreuzberg_unregister_ocr_backend".into(),
        other => format!("kreuzberg_{other}"),
    }
}
