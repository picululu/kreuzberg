// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
// To regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang rust

// Tests for embeddings fixtures.
#![allow(clippy::too_many_lines)]
use e2e_rust::{assertions, resolve_document};
use kreuzberg::KreuzbergError;
use kreuzberg::core::config::ExtractionConfig;

#[tokio::test]
async fn test_embedding_async() {
    // Tests embedding generation via async extraction path

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping embedding_async: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "chunking": {
    "embedding": {
      "model": {
        "preset": "balanced"
      },
      "normalize": true
    },
    "max_chars": 500,
    "max_overlap": 50
  }
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file(&document_path, None, &config).await {
        Err(KreuzbergError::MissingDependency(dep)) => {
            println!("Skipping embedding_async: missing dependency {dep}", dep = dep);
            return;
        }
        Err(KreuzbergError::UnsupportedFormat(fmt)) => {
            println!(
                "Skipping embedding_async: unsupported format {fmt} (requires optional tool)",
                fmt = fmt
            );
            return;
        }
        Err(err) => panic!("Extraction failed for embedding_async: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_chunks(&result, Some(1), None, Some(true), Some(true));
}

#[test]
fn test_embedding_balanced_preset() {
    // Tests embedding generation with balanced preset model via chunking

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping embedding_balanced_preset: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "chunking": {
    "embedding": {
      "model": {
        "preset": "balanced"
      },
      "normalize": true
    },
    "max_chars": 500,
    "max_overlap": 50
  }
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(KreuzbergError::MissingDependency(dep)) => {
            println!(
                "Skipping embedding_balanced_preset: missing dependency {dep}",
                dep = dep
            );
            return;
        }
        Err(KreuzbergError::UnsupportedFormat(fmt)) => {
            println!(
                "Skipping embedding_balanced_preset: unsupported format {fmt} (requires optional tool)",
                fmt = fmt
            );
            return;
        }
        Err(err) => panic!("Extraction failed for embedding_balanced_preset: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_chunks(&result, Some(1), None, Some(true), Some(true));
}

#[test]
fn test_embedding_disabled() {
    // Tests chunking without embeddings - chunks should not have embedding vectors

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping embedding_disabled: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "chunking": {
    "max_chars": 500,
    "max_overlap": 50
  }
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for embedding_disabled: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_chunks(&result, Some(1), None, Some(true), Some(false));
}

#[test]
fn test_embedding_fast_preset() {
    // Tests embedding generation with fast preset model

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping embedding_fast_preset: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "chunking": {
    "embedding": {
      "model": {
        "preset": "fast"
      },
      "normalize": true
    },
    "max_chars": 500,
    "max_overlap": 50
  }
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(KreuzbergError::MissingDependency(dep)) => {
            println!("Skipping embedding_fast_preset: missing dependency {dep}", dep = dep);
            return;
        }
        Err(KreuzbergError::UnsupportedFormat(fmt)) => {
            println!(
                "Skipping embedding_fast_preset: unsupported format {fmt} (requires optional tool)",
                fmt = fmt
            );
            return;
        }
        Err(err) => panic!("Extraction failed for embedding_fast_preset: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_chunks(&result, Some(1), None, Some(true), Some(true));
}
