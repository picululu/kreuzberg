// Auto-generated tests for email fixtures.
#![allow(clippy::too_many_lines)]
use e2e_rust::{assertions, resolve_document};
use kreuzberg::core::config::ExtractionConfig;

#[test]
fn test_email_eml_html_body() {
    // EML with HTML body content.

    let document_path = resolve_document("email/html_only.eml");
    if !document_path.exists() {
        println!(
            "Skipping email_eml_html_body: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config = ExtractionConfig::default();

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for email_eml_html_body: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["message/rfc822"]);
    assertions::assert_min_content_length(&result, 10);
}

#[test]
fn test_email_eml_multipart() {
    // EML with multipart MIME content.

    let document_path = resolve_document("email/html_email_multipart.eml");
    if !document_path.exists() {
        println!(
            "Skipping email_eml_multipart: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config = ExtractionConfig::default();

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for email_eml_multipart: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["message/rfc822"]);
    assertions::assert_min_content_length(&result, 10);
}

#[test]
fn test_email_eml_utf16() {
    // UTF-16 encoded EML file with BOM.

    let document_path = resolve_document("vendored/unstructured/eml/fake-email-utf-16.eml");
    if !document_path.exists() {
        println!(
            "Skipping email_eml_utf16: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config = ExtractionConfig::default();

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for email_eml_utf16: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["message/rfc822"]);
    assertions::assert_min_content_length(&result, 50);
    assertions::assert_content_contains_any(&result, &["Test Email", "Roses are red"]);
}

#[test]
fn test_email_msg_basic() {
    // Outlook MSG file extraction.

    let document_path = resolve_document("email/fake_email.msg");
    if !document_path.exists() {
        println!(
            "Skipping email_msg_basic: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config = ExtractionConfig::default();

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for email_msg_basic: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/vnd.ms-outlook"]);
    assertions::assert_min_content_length(&result, 10);
}

#[test]
fn test_email_sample_eml() {
    // Sample EML email file to verify email parsing.

    let document_path = resolve_document("email/sample_email.eml");
    if !document_path.exists() {
        println!(
            "Skipping email_sample_eml: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config = ExtractionConfig::default();

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for email_sample_eml: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["message/rfc822"]);
    assertions::assert_min_content_length(&result, 20);
}
