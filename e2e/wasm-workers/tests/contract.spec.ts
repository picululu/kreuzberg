// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
// To regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang wasm-workers

// Tests for contract fixtures. Cloudflare Workers with Vitest + Miniflare

import type { ExtractionResult } from "@kreuzberg/wasm";
import { batchExtractBytes, batchExtractBytesSync, extractBytes } from "@kreuzberg/wasm";
import { describe, expect, it } from "vitest";
import { assertions, buildConfig, getFixture, shouldSkipFixture } from "./helpers.js";

describe("contract", () => {
	it("api_batch_bytes_async", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig(undefined);
		let result: ExtractionResult | null = null;
		try {
			const results = await batchExtractBytes([{ data: documentBytes, mimeType: "application/octet-stream" }], config);
			result = results[0] ?? null;
		} catch (error) {
			if (shouldSkipFixture(error, "api_batch_bytes_async", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
	});

	it("api_batch_bytes_sync", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig(undefined);
		let result: ExtractionResult | null = null;
		try {
			const results = await batchExtractBytesSync(
				[{ data: documentBytes, mimeType: "application/octet-stream" }],
				config,
			);
			result = results[0] ?? null;
		} catch (error) {
			if (shouldSkipFixture(error, "api_batch_bytes_sync", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
	});

	it("api_batch_file_async", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig(undefined);
		let result: ExtractionResult | null = null;
		try {
			const results = await batchExtractBytes([{ data: documentBytes, mimeType: "application/octet-stream" }], config);
			result = results[0] ?? null;
		} catch (error) {
			if (shouldSkipFixture(error, "api_batch_file_async", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
	});

	it("api_batch_file_sync", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig(undefined);
		let result: ExtractionResult | null = null;
		try {
			const results = await batchExtractBytesSync(
				[{ data: documentBytes, mimeType: "application/octet-stream" }],
				config,
			);
			result = results[0] ?? null;
		} catch (error) {
			if (shouldSkipFixture(error, "api_batch_file_sync", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
	});

	it("api_extract_bytes_async", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig(undefined);
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "api_extract_bytes_async", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
	});

	it("api_extract_bytes_sync", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig(undefined);
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "api_extract_bytes_sync", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
	});

	it("api_extract_file_async", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig(undefined);
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "api_extract_file_async", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
	});

	it("api_extract_file_sync", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig(undefined);
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "api_extract_file_sync", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
	});

	it("config_chunking", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ chunking: { max_chars: 500, max_overlap: 50 } });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_chunking", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertChunks(result, 1, null, true, null);
	});

	it("config_chunking_markdown", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ chunking: { chunker_type: "markdown", max_chars: 500, max_overlap: 50 } });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_chunking_markdown", ["chunking"], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertChunks(result, 1, null, true, null);
	});

	it("config_chunking_small", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ chunking: { max_chars: 100, max_overlap: 20 } });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_chunking_small", ["chunking"], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertChunks(result, 2, null, true, null);
	});

	it("config_djot_content", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ output_format: "djot" });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_djot_content", ["pdf"], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
	});

	it("config_document_structure", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ include_document_structure: true });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_document_structure", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertDocument(result, true, 1, ["paragraph"], null);
	});

	it("config_document_structure_disabled", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig(undefined);
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_document_structure_disabled", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertDocument(result, false, null, null, null);
	});

	it("config_document_structure_headings", async () => {
		const documentBytes = getFixture("office/docx/headers.docx");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ include_document_structure: true });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_document_structure_headings", ["office"], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/vnd.openxmlformats-officedocument.wordprocessingml.document"]);
		assertions.assertDocument(result, true, 1, ["heading", "paragraph"], null);
	});

	it("config_document_structure_with_headings", async () => {
		const documentBytes = getFixture("docx/fake.docx");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ include_document_structure: true });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_document_structure_with_headings", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/vnd.openxmlformats-officedocument.wordprocessingml.document"]);
		assertions.assertDocument(result, true, 1, null, null);
	});

	it("config_element_types", async () => {
		const documentBytes = getFixture("office/docx/headers.docx");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ result_format: "element_based" });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_element_types", ["office"], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/vnd.openxmlformats-officedocument.wordprocessingml.document"]);
		assertions.assertElements(result, 1, ["title", "narrative_text"]);
	});

	it("config_force_ocr", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ force_ocr: true });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_force_ocr", ["tesseract"], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 5);
	});

	it("config_html_options", async () => {
		const documentBytes = getFixture("html/complex_table.html");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ html_options: { include_links: true } });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_html_options", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["text/html"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentNotEmpty(result);
	});

	it("config_images", async () => {
		const documentBytes = getFixture("pdf/embedded_images_tables.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ images: { extract_images: true } });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_images", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertImages(result, 1, null, null);
	});

	it("config_language_detection", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ language_detection: { enabled: true } });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_language_detection", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertDetectedLanguages(result, ["eng"], 0.5);
	});

	it("config_language_multi", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ language_detection: { detect_multiple: true, enabled: true } });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_language_multi", ["language-detection"], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertDetectedLanguages(result, ["eng"], null);
	});

	it("config_pages", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ pages: { extract_pages: true, insert_page_markers: true } });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_pages", ["pdf"], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentContainsAny(result, ["PAGE"]);
	});

	it("config_pages_extract", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ pages: { extract_pages: true } });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_pages_extract", ["pdf"], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertPages(result, 1, null);
	});

	it("config_pages_markers", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ pages: { insert_page_markers: true } });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_pages_markers", ["pdf"], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentContainsAny(result, ["PAGE"]);
	});

	it("config_pdf_hierarchy", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({
			pages: { extract_pages: true },
			pdf_options: { hierarchy: { enabled: true, include_bbox: true } },
		});
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_pdf_hierarchy", ["pdf"], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 50);
	});

	it("config_postprocessor", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ postprocessor: { enabled: true } });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_postprocessor", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentNotEmpty(result);
	});

	it("config_quality_disabled", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ enable_quality_processing: false });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_quality_disabled", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentNotEmpty(result);
	});

	it("config_quality_enabled", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ enable_quality_processing: true });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_quality_enabled", ["quality"], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertQualityScore(result, true, 0, 1);
	});

	it("config_structured_output", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ output_format: "structured" });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_structured_output", ["pdf"], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
	});

	it("config_use_cache_false", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ use_cache: false });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_use_cache_false", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
	});

	it("output_format_bytes_markdown", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ output_format: "markdown" });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "output_format_bytes_markdown", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
	});

	it("output_format_djot", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ output_format: "djot" });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "output_format_djot", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
	});

	it("output_format_html", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ output_format: "html" });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "output_format_html", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
	});

	it("output_format_markdown", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ output_format: "markdown" });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "output_format_markdown", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
	});

	it("output_format_plain", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ output_format: "plain" });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "output_format_plain", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
	});

	it("result_format_element_based", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ result_format: "element_based" });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "result_format_element_based", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertElements(result, 1, null);
	});

	it("result_format_unified", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ result_format: "unified" });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "result_format_unified", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
	});
});
