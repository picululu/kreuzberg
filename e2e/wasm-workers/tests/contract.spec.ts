// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
// To regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang wasm-workers

// Tests for contract fixtures. Cloudflare Workers with Vitest + Miniflare

import type { ExtractionResult } from "@kreuzberg/wasm";
import { batchExtractBytes, batchExtractBytesSync, extractBytes } from "@kreuzberg/wasm";
import { describe, expect, it } from "vitest";
import { assertions, buildConfig, getFixture, shouldSkipFixture } from "./helpers.js";

describe("contract", () => {
	it("api_batch_bytes_async", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig(undefined);
		let result: ExtractionResult | null = null;
		try {
			const results = await batchExtractBytes([{ data: documentBytes, mimeType: "application/octet-stream" }], config);
			result = results[0] ?? null;
		} catch (error) {
			if (shouldSkipFixture(error, "api_batch_bytes_async", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
	});

	it("api_batch_bytes_sync", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig(undefined);
		let result: ExtractionResult | null = null;
		try {
			const results = await batchExtractBytesSync(
				[{ data: documentBytes, mimeType: "application/octet-stream" }],
				config,
			);
			result = results[0] ?? null;
		} catch (error) {
			if (shouldSkipFixture(error, "api_batch_bytes_sync", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
	});

	it("api_batch_file_async", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig(undefined);
		let result: ExtractionResult | null = null;
		try {
			const results = await batchExtractBytes([{ data: documentBytes, mimeType: "application/octet-stream" }], config);
			result = results[0] ?? null;
		} catch (error) {
			if (shouldSkipFixture(error, "api_batch_file_async", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
	});

	it("api_batch_file_sync", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig(undefined);
		let result: ExtractionResult | null = null;
		try {
			const results = await batchExtractBytesSync(
				[{ data: documentBytes, mimeType: "application/octet-stream" }],
				config,
			);
			result = results[0] ?? null;
		} catch (error) {
			if (shouldSkipFixture(error, "api_batch_file_sync", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
	});

	it("api_extract_bytes_async", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig(undefined);
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "api_extract_bytes_async", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
	});

	it("api_extract_bytes_sync", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig(undefined);
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "api_extract_bytes_sync", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
	});

	it("api_extract_file_async", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig(undefined);
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "api_extract_file_async", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
	});

	it("api_extract_file_sync", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig(undefined);
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "api_extract_file_sync", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
	});

	it("config_chunking", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ chunking: { max_chars: 500, max_overlap: 50 } });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_chunking", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertChunks(result, 1, null, true, null);
	});

	it("config_document_structure", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ include_document_structure: true });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_document_structure", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertDocument(result, true, 1, ["paragraph"], null);
	});

	it("config_document_structure_disabled", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig(undefined);
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_document_structure_disabled", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertDocument(result, false, null, null, null);
	});

	it("config_document_structure_with_headings", async () => {
		const documentBytes = getFixture("docx/fake.docx");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ include_document_structure: true });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_document_structure_with_headings", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/vnd.openxmlformats-officedocument.wordprocessingml.document"]);
		assertions.assertDocument(result, true, 1, null, null);
	});

	it("config_force_ocr", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ force_ocr: true });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_force_ocr", ["tesseract"], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 5);
	});

	it("config_html_options", async () => {
		const documentBytes = getFixture("html/complex_table.html");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ html_options: { include_links: true } });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_html_options", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["text/html"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentNotEmpty(result);
	});

	it("config_images", async () => {
		const documentBytes = getFixture("pdf/embedded_images_tables.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ images: { extract_images: true } });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_images", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertImages(result, 1, null, null);
	});

	it("config_keywords", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ keywords: { algorithm: "yake", max_keywords: 10 } });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_keywords", ["keywords-yake"], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertMetadataExpectation(result, "keywords", { exists: true });
	});

	it("config_language_detection", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ language_detection: { enabled: true } });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_language_detection", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertDetectedLanguages(result, ["eng"], 0.5);
	});

	it("config_pages", async () => {
		const documentBytes = getFixture("pdf/multi_page.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ pages: { end: 3, start: 1 } });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_pages", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
	});

	it("config_quality_disabled", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ enable_quality_processing: false });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_quality_disabled", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
		assertions.assertContentNotEmpty(result);
	});

	it("config_use_cache_false", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ use_cache: false });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "config_use_cache_false", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
	});

	it("output_format_bytes_markdown", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ output_format: "markdown" });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "output_format_bytes_markdown", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
	});

	it("output_format_djot", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ output_format: "djot" });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "output_format_djot", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
	});

	it("output_format_html", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ output_format: "html" });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "output_format_html", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
	});

	it("output_format_markdown", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ output_format: "markdown" });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "output_format_markdown", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
	});

	it("output_format_plain", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ output_format: "plain" });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "output_format_plain", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
	});

	it("result_format_element_based", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ result_format: "element_based" });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "result_format_element_based", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertElements(result, 1, null);
	});

	it("result_format_unified", async () => {
		const documentBytes = getFixture("pdf/fake_memo.pdf");
		if (documentBytes === null) {
			console.warn("[SKIP] Test skipped: fixture not available in Cloudflare Workers environment");
			return;
		}

		const config = buildConfig({ result_format: "unified" });
		let result: ExtractionResult | null = null;
		try {
			result = await extractBytes(documentBytes, "application/octet-stream", config);
		} catch (error) {
			if (shouldSkipFixture(error, "result_format_unified", [], undefined)) {
				return;
			}
			throw error;
		}
		if (result === null) {
			return;
		}
		assertions.assertExpectedMime(result, ["application/pdf"]);
		assertions.assertMinContentLength(result, 10);
	});
});
