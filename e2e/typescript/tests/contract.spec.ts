// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
// To regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang typescript

// Tests for contract fixtures.

import { existsSync, readFileSync } from "node:fs";
import type { ExtractionResult } from "@kreuzberg/node";
import {
	batchExtractBytes,
	batchExtractBytesSync,
	batchExtractFiles,
	batchExtractFilesSync,
	detectMimeTypeFromPath,
	extractBytes,
	extractBytesSync,
	extractFile,
	extractFileSync,
} from "@kreuzberg/node";
import { describe, it } from "vitest";
import { assertions, buildConfig, chunkAssertions, resolveDocument, shouldSkipFixture } from "./helpers.js";

const TEST_TIMEOUT_MS = 60_000;

describe("contract fixtures", () => {
	it(
		"api_batch_bytes_async",
		async () => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping api_batch_bytes_async: missing document at", documentPath);
				return;
			}
			const config = buildConfig(undefined);
			let result: ExtractionResult | null = null;
			try {
				const fileBytes = readFileSync(documentPath);
				const mimeType = detectMimeTypeFromPath(documentPath);
				const results = await batchExtractBytes([fileBytes], [mimeType], config);
				result = results[0];
			} catch (error) {
				if (shouldSkipFixture(error, "api_batch_bytes_async", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
			assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"api_batch_bytes_sync",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping api_batch_bytes_sync: missing document at", documentPath);
				return;
			}
			const config = buildConfig(undefined);
			let result: ExtractionResult | null = null;
			try {
				const fileBytes = readFileSync(documentPath);
				const mimeType = detectMimeTypeFromPath(documentPath);
				const results = batchExtractBytesSync([fileBytes], [mimeType], config);
				result = results[0];
			} catch (error) {
				if (shouldSkipFixture(error, "api_batch_bytes_sync", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
			assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"api_batch_file_async",
		async () => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping api_batch_file_async: missing document at", documentPath);
				return;
			}
			const config = buildConfig(undefined);
			let result: ExtractionResult | null = null;
			try {
				const results = await batchExtractFiles([documentPath], config);
				result = results[0];
			} catch (error) {
				if (shouldSkipFixture(error, "api_batch_file_async", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
			assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"api_batch_file_sync",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping api_batch_file_sync: missing document at", documentPath);
				return;
			}
			const config = buildConfig(undefined);
			let result: ExtractionResult | null = null;
			try {
				const results = batchExtractFilesSync([documentPath], config);
				result = results[0];
			} catch (error) {
				if (shouldSkipFixture(error, "api_batch_file_sync", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
			assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"api_extract_bytes_async",
		async () => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping api_extract_bytes_async: missing document at", documentPath);
				return;
			}
			const config = buildConfig(undefined);
			let result: ExtractionResult | null = null;
			try {
				const fileBytes = readFileSync(documentPath);
				const mimeType = detectMimeTypeFromPath(documentPath);
				result = await extractBytes(fileBytes, mimeType, config);
			} catch (error) {
				if (shouldSkipFixture(error, "api_extract_bytes_async", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
			assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"api_extract_bytes_sync",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping api_extract_bytes_sync: missing document at", documentPath);
				return;
			}
			const config = buildConfig(undefined);
			let result: ExtractionResult | null = null;
			try {
				const fileBytes = readFileSync(documentPath);
				const mimeType = detectMimeTypeFromPath(documentPath);
				result = extractBytesSync(fileBytes, mimeType, config);
			} catch (error) {
				if (shouldSkipFixture(error, "api_extract_bytes_sync", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
			assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"api_extract_file_async",
		async () => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping api_extract_file_async: missing document at", documentPath);
				return;
			}
			const config = buildConfig(undefined);
			let result: ExtractionResult | null = null;
			try {
				result = await extractFile(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "api_extract_file_async", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
			assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"api_extract_file_sync",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping api_extract_file_sync: missing document at", documentPath);
				return;
			}
			const config = buildConfig(undefined);
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "api_extract_file_sync", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
			assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"config_chunking",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping config_chunking: missing document at", documentPath);
				return;
			}
			const config = buildConfig({ chunking: { max_chars: 500, max_overlap: 50 } });
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "config_chunking", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
			chunkAssertions.assertChunks(result, 1, null, true, null);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"config_document_structure",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping config_document_structure: missing document at", documentPath);
				return;
			}
			const config = buildConfig({ include_document_structure: true });
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "config_document_structure", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			chunkAssertions.assertDocument(result, true, 1, ["paragraph"], null);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"config_document_structure_disabled",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping config_document_structure_disabled: missing document at", documentPath);
				return;
			}
			const config = buildConfig(undefined);
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "config_document_structure_disabled", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			chunkAssertions.assertDocument(result, false, null, null, null);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"config_document_structure_with_headings",
		() => {
			const documentPath = resolveDocument("docx/fake.docx");
			if (!existsSync(documentPath)) {
				console.warn("Skipping config_document_structure_with_headings: missing document at", documentPath);
				return;
			}
			const config = buildConfig({ include_document_structure: true });
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "config_document_structure_with_headings", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, [
				"application/vnd.openxmlformats-officedocument.wordprocessingml.document",
			]);
			chunkAssertions.assertDocument(result, true, 1, null, null);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"config_force_ocr",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping config_force_ocr: missing document at", documentPath);
				return;
			}
			const config = buildConfig({ force_ocr: true });
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "config_force_ocr", ["tesseract"], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 5);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"config_html_options",
		() => {
			const documentPath = resolveDocument("html/complex_table.html");
			if (!existsSync(documentPath)) {
				console.warn("Skipping config_html_options: missing document at", documentPath);
				return;
			}
			const config = buildConfig({ html_options: { include_links: true } });
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "config_html_options", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["text/html"]);
			assertions.assertMinContentLength(result, 10);
			assertions.assertContentNotEmpty(result);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"config_images",
		() => {
			const documentPath = resolveDocument("pdf/embedded_images_tables.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping config_images: missing document at", documentPath);
				return;
			}
			const config = buildConfig({ images: { extract_images: true } });
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "config_images", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			chunkAssertions.assertImages(result, 1, null, null);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"config_keywords",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping config_keywords: missing document at", documentPath);
				return;
			}
			const config = buildConfig({ keywords: { algorithm: "yake", max_keywords: 10 } });
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "config_keywords", ["keywords-yake"], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
			assertions.assertKeywords(result, true, 1, null);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"config_language_detection",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping config_language_detection: missing document at", documentPath);
				return;
			}
			const config = buildConfig({ language_detection: { enabled: true } });
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "config_language_detection", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
			assertions.assertDetectedLanguages(result, ["eng"], 0.5);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"config_pages",
		() => {
			const documentPath = resolveDocument("pdf/multi_page.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping config_pages: missing document at", documentPath);
				return;
			}
			const config = buildConfig({ pages: { end: 3, start: 1 } });
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "config_pages", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"config_quality_disabled",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping config_quality_disabled: missing document at", documentPath);
				return;
			}
			const config = buildConfig({ enable_quality_processing: false });
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "config_quality_disabled", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
			assertions.assertContentNotEmpty(result);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"config_use_cache_false",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping config_use_cache_false: missing document at", documentPath);
				return;
			}
			const config = buildConfig({ use_cache: false });
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "config_use_cache_false", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"output_format_bytes_markdown",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping output_format_bytes_markdown: missing document at", documentPath);
				return;
			}
			const config = buildConfig({ output_format: "markdown" });
			let result: ExtractionResult | null = null;
			try {
				const fileBytes = readFileSync(documentPath);
				const mimeType = detectMimeTypeFromPath(documentPath);
				result = extractBytesSync(fileBytes, mimeType, config);
			} catch (error) {
				if (shouldSkipFixture(error, "output_format_bytes_markdown", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"output_format_djot",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping output_format_djot: missing document at", documentPath);
				return;
			}
			const config = buildConfig({ output_format: "djot" });
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "output_format_djot", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"output_format_html",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping output_format_html: missing document at", documentPath);
				return;
			}
			const config = buildConfig({ output_format: "html" });
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "output_format_html", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"output_format_markdown",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping output_format_markdown: missing document at", documentPath);
				return;
			}
			const config = buildConfig({ output_format: "markdown" });
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "output_format_markdown", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"output_format_plain",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping output_format_plain: missing document at", documentPath);
				return;
			}
			const config = buildConfig({ output_format: "plain" });
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "output_format_plain", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"result_format_element_based",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping result_format_element_based: missing document at", documentPath);
				return;
			}
			const config = buildConfig({ result_format: "element_based" });
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "result_format_element_based", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			chunkAssertions.assertElements(result, 1, null);
		},
		TEST_TIMEOUT_MS,
	);

	it(
		"result_format_unified",
		() => {
			const documentPath = resolveDocument("pdf/fake_memo.pdf");
			if (!existsSync(documentPath)) {
				console.warn("Skipping result_format_unified: missing document at", documentPath);
				return;
			}
			const config = buildConfig({ result_format: "unified" });
			let result: ExtractionResult | null = null;
			try {
				result = extractFileSync(documentPath, null, config);
			} catch (error) {
				if (shouldSkipFixture(error, "result_format_unified", [], undefined)) {
					return;
				}
				throw error;
			}
			if (result === null) {
				return;
			}
			assertions.assertExpectedMime(result, ["application/pdf"]);
			assertions.assertMinContentLength(result, 10);
		},
		TEST_TIMEOUT_MS,
	);
});
