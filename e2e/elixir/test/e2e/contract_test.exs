# Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
# To regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang elixir
#
# Tests for contract fixtures.

# To regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang elixir

defmodule E2E.ContractTest do
  use ExUnit.Case, async: false

  describe "contract fixtures" do
    test "api_batch_bytes_async" do
      case E2E.Helpers.run_fixture_with_method(
             "api_batch_bytes_async",
             "pdf/fake_memo.pdf",
             nil,
             :batch_async,
             :bytes,
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)
          |> E2E.Helpers.assert_content_contains_any(["May 5, 2023", "Mallori"])

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "api_batch_bytes_sync" do
      case E2E.Helpers.run_fixture_with_method(
             "api_batch_bytes_sync",
             "pdf/fake_memo.pdf",
             nil,
             :batch_sync,
             :bytes,
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)
          |> E2E.Helpers.assert_content_contains_any(["May 5, 2023", "Mallori"])

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "api_batch_file_async" do
      case E2E.Helpers.run_fixture_with_method(
             "api_batch_file_async",
             "pdf/fake_memo.pdf",
             nil,
             :batch_async,
             :file,
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)
          |> E2E.Helpers.assert_content_contains_any(["May 5, 2023", "Mallori"])

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "api_batch_file_sync" do
      case E2E.Helpers.run_fixture_with_method(
             "api_batch_file_sync",
             "pdf/fake_memo.pdf",
             nil,
             :batch_sync,
             :file,
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)
          |> E2E.Helpers.assert_content_contains_any(["May 5, 2023", "Mallori"])

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "api_extract_bytes_async" do
      case E2E.Helpers.run_fixture_with_method(
             "api_extract_bytes_async",
             "pdf/fake_memo.pdf",
             nil,
             :async,
             :bytes,
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)
          |> E2E.Helpers.assert_content_contains_any(["May 5, 2023", "Mallori"])

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "api_extract_bytes_sync" do
      case E2E.Helpers.run_fixture_with_method(
             "api_extract_bytes_sync",
             "pdf/fake_memo.pdf",
             nil,
             :sync,
             :bytes,
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)
          |> E2E.Helpers.assert_content_contains_any(["May 5, 2023", "Mallori"])

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "api_extract_file_async" do
      case E2E.Helpers.run_fixture_with_method(
             "api_extract_file_async",
             "pdf/fake_memo.pdf",
             nil,
             :async,
             :file,
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)
          |> E2E.Helpers.assert_content_contains_any(["May 5, 2023", "Mallori"])

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "api_extract_file_sync" do
      case E2E.Helpers.run_fixture(
             "api_extract_file_sync",
             "pdf/fake_memo.pdf",
             nil,
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)
          |> E2E.Helpers.assert_content_contains_any(["May 5, 2023", "Mallori"])

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "config_chunking" do
      case E2E.Helpers.run_fixture(
             "config_chunking",
             "pdf/fake_memo.pdf",
             %{chunking: %{max_chars: 500, max_overlap: 50}},
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)
          |> E2E.Helpers.assert_chunks(min_count: 1, each_has_content: true)

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "config_document_structure" do
      case E2E.Helpers.run_fixture(
             "config_document_structure",
             "pdf/fake_memo.pdf",
             %{include_document_structure: true},
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_document(has_document: true, min_node_count: 1, node_types_include: ["paragraph"])

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "config_document_structure_disabled" do
      case E2E.Helpers.run_fixture(
             "config_document_structure_disabled",
             "pdf/fake_memo.pdf",
             nil,
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_document(has_document: false)

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "config_document_structure_with_headings" do
      case E2E.Helpers.run_fixture(
             "config_document_structure_with_headings",
             "docx/fake.docx",
             %{include_document_structure: true},
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime([
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
          ])
          |> E2E.Helpers.assert_document(has_document: true, min_node_count: 1)

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "config_force_ocr" do
      case E2E.Helpers.run_fixture(
             "config_force_ocr",
             "pdf/fake_memo.pdf",
             %{force_ocr: true},
             requirements: ["tesseract"],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(5)

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "config_html_options" do
      case E2E.Helpers.run_fixture(
             "config_html_options",
             "html/complex_table.html",
             %{html_options: %{include_links: true}},
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["text/html"])
          |> E2E.Helpers.assert_min_content_length(10)
          |> E2E.Helpers.assert_content_not_empty()

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "config_images" do
      case E2E.Helpers.run_fixture(
             "config_images",
             "pdf/embedded_images_tables.pdf",
             %{images: %{extract_images: true}},
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_images(min_count: 1)

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "config_keywords" do
      case E2E.Helpers.run_fixture(
             "config_keywords",
             "pdf/fake_memo.pdf",
             %{keywords: %{algorithm: "yake", max_keywords: 10}},
             requirements: ["keywords-yake"],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)
          |> E2E.Helpers.assert_keywords(has_keywords: true, min_count: 1)

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "config_language_detection" do
      case E2E.Helpers.run_fixture(
             "config_language_detection",
             "pdf/fake_memo.pdf",
             %{language_detection: %{enabled: true}},
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)
          |> E2E.Helpers.assert_detected_languages(["eng"], 0.5)

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "config_pages" do
      case E2E.Helpers.run_fixture(
             "config_pages",
             "pdf/multi_page.pdf",
             %{pages: %{end: 3, start: 1}},
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "config_quality_disabled" do
      case E2E.Helpers.run_fixture(
             "config_quality_disabled",
             "pdf/fake_memo.pdf",
             %{enable_quality_processing: false},
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)
          |> E2E.Helpers.assert_content_not_empty()

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "config_use_cache_false" do
      case E2E.Helpers.run_fixture(
             "config_use_cache_false",
             "pdf/fake_memo.pdf",
             %{use_cache: false},
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "output_format_bytes_markdown" do
      case E2E.Helpers.run_fixture_with_method(
             "output_format_bytes_markdown",
             "pdf/fake_memo.pdf",
             %{output_format: "markdown"},
             :sync,
             :bytes,
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "output_format_djot" do
      case E2E.Helpers.run_fixture(
             "output_format_djot",
             "pdf/fake_memo.pdf",
             %{output_format: "djot"},
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "output_format_html" do
      case E2E.Helpers.run_fixture(
             "output_format_html",
             "pdf/fake_memo.pdf",
             %{output_format: "html"},
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "output_format_markdown" do
      case E2E.Helpers.run_fixture(
             "output_format_markdown",
             "pdf/fake_memo.pdf",
             %{output_format: "markdown"},
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "output_format_plain" do
      case E2E.Helpers.run_fixture(
             "output_format_plain",
             "pdf/fake_memo.pdf",
             %{output_format: "plain"},
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "result_format_element_based" do
      case E2E.Helpers.run_fixture(
             "result_format_element_based",
             "pdf/fake_memo.pdf",
             %{result_format: "element_based"},
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_elements(min_count: 1)

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end

    test "result_format_unified" do
      case E2E.Helpers.run_fixture(
             "result_format_unified",
             "pdf/fake_memo.pdf",
             %{result_format: "unified"},
             requirements: [],
             notes: nil,
             skip_if_missing: true
           ) do
        {:ok, result} ->
          result
          |> E2E.Helpers.assert_expected_mime(["application/pdf"])
          |> E2E.Helpers.assert_min_content_length(10)

        {:skipped, reason} ->
          IO.puts("SKIPPED: #{reason}")

        {:error, reason} ->
          flunk("Extraction failed: #{inspect(reason)}")
      end
    end
  end
end
