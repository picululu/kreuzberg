/* Generated by kreuzberg-e2e-generator. DO NOT EDIT. */
#pragma once

#include "kreuzberg.h"
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <sys/stat.h>

#if defined(_WIN32) || defined(__CYGWIN__)
#  define PATH_SEP "\\"
#else
#  define PATH_SEP "/"
#endif

/* Resolve the workspace root (two levels above the directory containing
   the test binary).  Returns a heap-allocated string that must be freed. */
char *resolve_workspace_root(void);

/* Join workspace-root / "test_documents" / relative path.
   Returns a heap-allocated string that must be freed. */
char *resolve_document(const char *relative);

/* Ensure a document file exists.  If skip_if_missing is non-zero and the
   file does not exist, prints "SKIP: …" to stdout and returns NULL without
   aborting.  On any other error, prints to stderr and calls exit(1).
   Returns a heap-allocated path string that must be freed (or NULL on skip). */
char *ensure_document(const char *relative, int skip_if_missing);

/* Build an ExtractionConfig from a JSON string.  Pass NULL to get NULL back
   (meaning "use defaults").  Calls exit(1) on parse failure. */
ExtractionConfig *build_config(const char *json_str);

/* Returns non-zero if the result's error indicates a missing dependency. */
int should_skip_missing_dependency(const CExtractionResult *result);

/* Run synchronous file extraction, handling skip / error cases.
   Returns NULL (after printing SKIP) when the document is absent and
   skip_if_missing was set.  Calls exit(1) on hard failure.
   config_json may be NULL. */
CExtractionResult *run_extraction(const char *relative, const char *config_json);

/* Like run_extraction but reads the file into memory and calls the bytes API. */
CExtractionResult *run_extraction_bytes(const char *relative, const char *config_json);

/* Check an environment variable like KREUZBERG_PADDLE_OCR_AVAILABLE.
   If unset / "0" / "false", prints "SKIP:" and returns 1 (caller should return).
   Otherwise returns 0. */
int skip_if_feature_unavailable(const char *feature);

/* Case-insensitive substring search.  Returns non-zero if needle found in haystack. */
int str_contains_ci(const char *haystack, const char *needle);

/* Count JSON array elements by counting top-level commas +1 in a "[…]" string.
   Returns 0 for NULL or empty array "[]". */
size_t json_array_count(const char *json);

/* Assertion helpers – each calls exit(1) on failure after printing a message. */

void assert_expected_mime(const CExtractionResult *result,
                          const char *const *mimes, size_t count);

void assert_min_content_length(const CExtractionResult *result, size_t min);

void assert_max_content_length(const CExtractionResult *result, size_t max);

void assert_content_contains_any(const CExtractionResult *result,
                                 const char *const *snippets, size_t count);

void assert_content_contains_all(const CExtractionResult *result,
                                 const char *const *snippets, size_t count);

void assert_content_not_empty(const CExtractionResult *result);

/* min/max flags: pass -1 to disable that bound */
void assert_table_count(const CExtractionResult *result,
                        int has_min, size_t min,
                        int has_max, size_t max);

void assert_detected_languages(const CExtractionResult *result,
                               const char *const *expected, size_t count);

void assert_chunks(const CExtractionResult *result,
                   int has_min, size_t min_count,
                   int has_max, size_t max_count);

void assert_images(const CExtractionResult *result,
                   int has_min, size_t min_count,
                   int has_max, size_t max_count);

void assert_pages(const CExtractionResult *result,
                  int has_min, size_t min_count,
                  int has_exact, size_t exact_count);

void assert_elements(const CExtractionResult *result,
                     int has_min, size_t min_count);

void assert_ocr_elements(const CExtractionResult *result,
                         int has_elements,
                         int has_geometry,
                         int has_confidence,
                         int has_min, size_t min_count);

void assert_document(const CExtractionResult *result,
                     int has_document,
                     int has_min_node_count, size_t min_node_count);

void assert_keywords(const CExtractionResult *result,
                     int has_kw, int kw_present,
                     int has_min, size_t min_count,
                     int has_max, size_t max_count);

void assert_quality_score(const CExtractionResult *result,
                          int has_score, int score_present,
                          int has_min, double min_score,
                          int has_max, double max_score);

void assert_processing_warnings(const CExtractionResult *result,
                                int has_max, size_t max_count,
                                int has_is_empty, int is_empty);

void assert_djot_content(const CExtractionResult *result,
                         int has_content, int content_present,
                         int has_min_blocks, size_t min_blocks);

void assert_annotations(const CExtractionResult *result,
                        int has_annotations,
                        int has_min, size_t min_count);
