/* Code generated by kreuzberg-e2e-generator. DO NOT EDIT. */
/* Category: contract */

#include "helpers.h"
#include <stdio.h>

static void test_contract_api_batch_bytes_async(void) {
    char *doc_path = ensure_document("pdf/fake_memo.pdf", 1);
    if (!doc_path) return; /* document missing */
    const char *batch_paths[] = { doc_path };
    CBatchResult *batch = kreuzberg_batch_extract_files_sync(batch_paths, 1, NULL);
    free(doc_path);
    if (!batch) {
        printf("SKIP: batch extraction returned NULL for %s\n", "pdf/fake_memo.pdf");
        return;
    }
    if (!batch->success || batch->count == 0) {
        printf("SKIP: batch extraction unsuccessful for %s\n", "pdf/fake_memo.pdf");
        kreuzberg_free_batch_result(batch);
        return;
    }
    CExtractionResult *result = batch->results[0];
    if (!result || !result->success) {
        printf("SKIP: batch result[0] unsuccessful for %s\n", "pdf/fake_memo.pdf");
        kreuzberg_free_batch_result(batch);
        return;
    }
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_content_contains_any(result, (const char *[]){"May 5, 2023", "Mallori"}, 2);
    kreuzberg_free_batch_result(batch);
}

static void test_contract_api_batch_bytes_sync(void) {
    char *doc_path = ensure_document("pdf/fake_memo.pdf", 1);
    if (!doc_path) return; /* document missing */
    const char *batch_paths[] = { doc_path };
    CBatchResult *batch = kreuzberg_batch_extract_files_sync(batch_paths, 1, NULL);
    free(doc_path);
    if (!batch) {
        printf("SKIP: batch extraction returned NULL for %s\n", "pdf/fake_memo.pdf");
        return;
    }
    if (!batch->success || batch->count == 0) {
        printf("SKIP: batch extraction unsuccessful for %s\n", "pdf/fake_memo.pdf");
        kreuzberg_free_batch_result(batch);
        return;
    }
    CExtractionResult *result = batch->results[0];
    if (!result || !result->success) {
        printf("SKIP: batch result[0] unsuccessful for %s\n", "pdf/fake_memo.pdf");
        kreuzberg_free_batch_result(batch);
        return;
    }
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_content_contains_any(result, (const char *[]){"May 5, 2023", "Mallori"}, 2);
    kreuzberg_free_batch_result(batch);
}

static void test_contract_api_batch_file_async(void) {
    char *doc_path = ensure_document("pdf/fake_memo.pdf", 1);
    if (!doc_path) return; /* document missing */
    const char *batch_paths[] = { doc_path };
    CBatchResult *batch = kreuzberg_batch_extract_files_sync(batch_paths, 1, NULL);
    free(doc_path);
    if (!batch) {
        printf("SKIP: batch extraction returned NULL for %s\n", "pdf/fake_memo.pdf");
        return;
    }
    if (!batch->success || batch->count == 0) {
        printf("SKIP: batch extraction unsuccessful for %s\n", "pdf/fake_memo.pdf");
        kreuzberg_free_batch_result(batch);
        return;
    }
    CExtractionResult *result = batch->results[0];
    if (!result || !result->success) {
        printf("SKIP: batch result[0] unsuccessful for %s\n", "pdf/fake_memo.pdf");
        kreuzberg_free_batch_result(batch);
        return;
    }
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_content_contains_any(result, (const char *[]){"May 5, 2023", "Mallori"}, 2);
    kreuzberg_free_batch_result(batch);
}

static void test_contract_api_batch_file_sync(void) {
    char *doc_path = ensure_document("pdf/fake_memo.pdf", 1);
    if (!doc_path) return; /* document missing */
    const char *batch_paths[] = { doc_path };
    CBatchResult *batch = kreuzberg_batch_extract_files_sync(batch_paths, 1, NULL);
    free(doc_path);
    if (!batch) {
        printf("SKIP: batch extraction returned NULL for %s\n", "pdf/fake_memo.pdf");
        return;
    }
    if (!batch->success || batch->count == 0) {
        printf("SKIP: batch extraction unsuccessful for %s\n", "pdf/fake_memo.pdf");
        kreuzberg_free_batch_result(batch);
        return;
    }
    CExtractionResult *result = batch->results[0];
    if (!result || !result->success) {
        printf("SKIP: batch result[0] unsuccessful for %s\n", "pdf/fake_memo.pdf");
        kreuzberg_free_batch_result(batch);
        return;
    }
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_content_contains_any(result, (const char *[]){"May 5, 2023", "Mallori"}, 2);
    kreuzberg_free_batch_result(batch);
}

static void test_contract_api_extract_bytes_async(void) {
    CExtractionResult *result = run_extraction_bytes("pdf/fake_memo.pdf", NULL);
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_content_contains_any(result, (const char *[]){"May 5, 2023", "Mallori"}, 2);
    kreuzberg_free_result(result);
}

static void test_contract_api_extract_bytes_sync(void) {
    CExtractionResult *result = run_extraction_bytes("pdf/fake_memo.pdf", NULL);
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_content_contains_any(result, (const char *[]){"May 5, 2023", "Mallori"}, 2);
    kreuzberg_free_result(result);
}

static void test_contract_api_extract_file_async(void) {
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", NULL);
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_content_contains_any(result, (const char *[]){"May 5, 2023", "Mallori"}, 2);
    kreuzberg_free_result(result);
}

static void test_contract_api_extract_file_sync(void) {
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", NULL);
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_content_contains_any(result, (const char *[]){"May 5, 2023", "Mallori"}, 2);
    kreuzberg_free_result(result);
}

static void test_contract_config_chunking(void) {
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"chunking\":{\"max_chars\":500,\"max_overlap\":50}}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_chunks(result, 1, 1, 0, 0);
    kreuzberg_free_result(result);
}

static void test_contract_config_chunking_markdown(void) {
    if (skip_if_feature_unavailable("chunking")) return;
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"chunking\":{\"chunker_type\":\"markdown\",\"max_chars\":500,\"max_overlap\":50}}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_chunks(result, 1, 1, 0, 0);
    kreuzberg_free_result(result);
}

static void test_contract_config_chunking_small(void) {
    if (skip_if_feature_unavailable("chunking")) return;
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"chunking\":{\"max_chars\":100,\"max_overlap\":20}}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_chunks(result, 1, 2, 0, 0);
    kreuzberg_free_result(result);
}

static void test_contract_config_djot_content(void) {
    if (skip_if_feature_unavailable("pdf")) return;
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"output_format\":\"djot\"}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    kreuzberg_free_result(result);
}

static void test_contract_config_document_structure(void) {
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"include_document_structure\":true}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_document(result, 1, 1, 1);
    kreuzberg_free_result(result);
}

static void test_contract_config_document_structure_disabled(void) {
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", NULL);
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_document(result, 0, 0, 0);
    kreuzberg_free_result(result);
}

static void test_contract_config_document_structure_headings(void) {
    if (skip_if_feature_unavailable("office")) return;
    CExtractionResult *result = run_extraction("docx/unit_test_headers.docx", "{\"include_document_structure\":true}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/vnd.openxmlformats-officedocument.wordprocessingml.document"}, 1);
    assert_document(result, 1, 1, 1);
    kreuzberg_free_result(result);
}

static void test_contract_config_document_structure_with_headings(void) {
    CExtractionResult *result = run_extraction("docx/fake.docx", "{\"include_document_structure\":true}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/vnd.openxmlformats-officedocument.wordprocessingml.document"}, 1);
    assert_document(result, 1, 1, 1);
    kreuzberg_free_result(result);
}

static void test_contract_config_element_types(void) {
    if (skip_if_feature_unavailable("office")) return;
    CExtractionResult *result = run_extraction("docx/unit_test_headers.docx", "{\"result_format\":\"element_based\"}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/vnd.openxmlformats-officedocument.wordprocessingml.document"}, 1);
    assert_elements(result, 1, 1);
    kreuzberg_free_result(result);
}

static void test_contract_config_force_ocr(void) {
    if (skip_if_feature_unavailable("tesseract")) return;
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"force_ocr\":true}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 5);
    kreuzberg_free_result(result);
}

static void test_contract_config_html_options(void) {
    CExtractionResult *result = run_extraction("html/complex_table.html", "{\"html_options\":{\"include_links\":true}}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"text/html"}, 1);
    assert_min_content_length(result, 10);
    assert_content_not_empty(result);
    kreuzberg_free_result(result);
}

static void test_contract_config_images(void) {
    CExtractionResult *result = run_extraction("pdf/embedded_images_tables.pdf", "{\"images\":{\"extract_images\":true}}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_images(result, 1, 1, 0, 0);
    kreuzberg_free_result(result);
}

static void test_contract_config_keywords(void) {
    if (skip_if_feature_unavailable("keywords-yake")) return;
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"keywords\":{\"algorithm\":\"yake\",\"max_keywords\":10}}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_keywords(result, 1, 1, 1, 1, 0, 0);
    kreuzberg_free_result(result);
}

static void test_contract_config_language_detection(void) {
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"language_detection\":{\"enabled\":true}}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_detected_languages(result, (const char *[]){"eng"}, 1);
    kreuzberg_free_result(result);
}

static void test_contract_config_language_multi(void) {
    if (skip_if_feature_unavailable("language-detection")) return;
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"language_detection\":{\"detect_multiple\":true,\"enabled\":true}}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_detected_languages(result, (const char *[]){"eng"}, 1);
    kreuzberg_free_result(result);
}

static void test_contract_config_pages(void) {
    if (skip_if_feature_unavailable("pdf")) return;
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"pages\":{\"extract_pages\":true,\"insert_page_markers\":true}}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_content_contains_any(result, (const char *[]){"PAGE"}, 1);
    kreuzberg_free_result(result);
}

static void test_contract_config_pages_extract(void) {
    if (skip_if_feature_unavailable("pdf")) return;
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"pages\":{\"extract_pages\":true}}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_pages(result, 1, 1, 0, 0);
    kreuzberg_free_result(result);
}

static void test_contract_config_pages_markers(void) {
    if (skip_if_feature_unavailable("pdf")) return;
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"pages\":{\"insert_page_markers\":true}}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_content_contains_any(result, (const char *[]){"PAGE"}, 1);
    kreuzberg_free_result(result);
}

static void test_contract_config_pdf_hierarchy(void) {
    if (skip_if_feature_unavailable("pdf")) return;
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"pages\":{\"extract_pages\":true},\"pdf_options\":{\"hierarchy\":{\"enabled\":true,\"include_bbox\":true}}}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 50);
    kreuzberg_free_result(result);
}

static void test_contract_config_postprocessor(void) {
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"postprocessor\":{\"enabled\":true}}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_content_not_empty(result);
    kreuzberg_free_result(result);
}

static void test_contract_config_quality_disabled(void) {
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"enable_quality_processing\":false}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_content_not_empty(result);
    kreuzberg_free_result(result);
}

static void test_contract_config_quality_enabled(void) {
    if (skip_if_feature_unavailable("quality")) return;
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"enable_quality_processing\":true}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    assert_quality_score(result, 1, 1, 1, 0, 1, 1);
    kreuzberg_free_result(result);
}

static void test_contract_config_structured_output(void) {
    if (skip_if_feature_unavailable("pdf")) return;
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"output_format\":\"structured\"}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    kreuzberg_free_result(result);
}

static void test_contract_config_use_cache_false(void) {
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"use_cache\":false}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    kreuzberg_free_result(result);
}

static void test_contract_output_format_bytes_markdown(void) {
    CExtractionResult *result = run_extraction_bytes("pdf/fake_memo.pdf", "{\"output_format\":\"markdown\"}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    kreuzberg_free_result(result);
}

static void test_contract_output_format_djot(void) {
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"output_format\":\"djot\"}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    kreuzberg_free_result(result);
}

static void test_contract_output_format_html(void) {
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"output_format\":\"html\"}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    kreuzberg_free_result(result);
}

static void test_contract_output_format_markdown(void) {
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"output_format\":\"markdown\"}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    kreuzberg_free_result(result);
}

static void test_contract_output_format_plain(void) {
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"output_format\":\"plain\"}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    kreuzberg_free_result(result);
}

static void test_contract_result_format_element_based(void) {
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"result_format\":\"element_based\"}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_elements(result, 1, 1);
    kreuzberg_free_result(result);
}

static void test_contract_result_format_unified(void) {
    CExtractionResult *result = run_extraction("pdf/fake_memo.pdf", "{\"result_format\":\"unified\"}");
    if (!result) return; /* skipped */
    assert_expected_mime(result, (const char *[]){"application/pdf"}, 1);
    assert_min_content_length(result, 10);
    kreuzberg_free_result(result);
}

int main(void) {
    test_contract_api_batch_bytes_async();
    test_contract_api_batch_bytes_sync();
    test_contract_api_batch_file_async();
    test_contract_api_batch_file_sync();
    test_contract_api_extract_bytes_async();
    test_contract_api_extract_bytes_sync();
    test_contract_api_extract_file_async();
    test_contract_api_extract_file_sync();
    test_contract_config_chunking();
    test_contract_config_chunking_markdown();
    test_contract_config_chunking_small();
    test_contract_config_djot_content();
    test_contract_config_document_structure();
    test_contract_config_document_structure_disabled();
    test_contract_config_document_structure_headings();
    test_contract_config_document_structure_with_headings();
    test_contract_config_element_types();
    test_contract_config_force_ocr();
    test_contract_config_html_options();
    test_contract_config_images();
    test_contract_config_keywords();
    test_contract_config_language_detection();
    test_contract_config_language_multi();
    test_contract_config_pages();
    test_contract_config_pages_extract();
    test_contract_config_pages_markers();
    test_contract_config_pdf_hierarchy();
    test_contract_config_postprocessor();
    test_contract_config_quality_disabled();
    test_contract_config_quality_enabled();
    test_contract_config_structured_output();
    test_contract_config_use_cache_false();
    test_contract_output_format_bytes_markdown();
    test_contract_output_format_djot();
    test_contract_output_format_html();
    test_contract_output_format_markdown();
    test_contract_output_format_plain();
    test_contract_result_format_element_based();
    test_contract_result_format_unified();
    printf("test_contract: all tests passed\n");
    return 0;
}
