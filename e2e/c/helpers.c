/* Generated by kreuzberg-e2e-generator. DO NOT EDIT. */
#include "helpers.h"
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---- workspace / document helpers --------------------------------------- */

char *resolve_workspace_root(void) {
    /* The test binary lives in e2e/c/.  Go two levels up to the workspace. */
#if defined(_WIN32) || defined(__CYGWIN__)
    /* On Windows use GetModuleFileName – fall back to relative path. */
    char *root = (char *)malloc(4096);
    if (!root) { fputs("OOM\n", stderr); exit(1); }
    strcpy(root, ".." PATH_SEP "..");
    return root;
#else
    char exe_path[4096] = {0};
    ssize_t n = -1;
#  if defined(__linux__)
    n = readlink("/proc/self/exe", exe_path, sizeof(exe_path) - 1);
#  elif defined(__APPLE__)
    {
        uint32_t sz = (uint32_t)(sizeof(exe_path) - 1);
        extern int _NSGetExecutablePath(char *, uint32_t *);
        if (_NSGetExecutablePath(exe_path, &sz) == 0) n = (ssize_t)strlen(exe_path);
    }
#  endif
    if (n <= 0) {
        /* Fallback: use cwd relative path */
        char *root = (char *)malloc(8);
        if (!root) { fputs("OOM\n", stderr); exit(1); }
        strcpy(root, ".." PATH_SEP "..");
        return root;
    }
    exe_path[n] = '\0';

    /* Dirname twice to go from  .../e2e/c/test_xxx  ->  .../e2e/c  ->  .../e2e  ->  workspace */
    char *slash = strrchr(exe_path, '/');
    if (slash) *slash = '\0'; /* strip binary name -> .../e2e/c */
    slash = strrchr(exe_path, '/');
    if (slash) *slash = '\0'; /* strip "c"        -> .../e2e   */
    slash = strrchr(exe_path, '/');
    if (slash) *slash = '\0'; /* strip "e2e"      -> workspace  */

    char resolved[4096] = {0};
    if (realpath(exe_path, resolved) == NULL) {
        /* realpath failed; just return what we have */
        strcpy(resolved, exe_path);
    }

    char *root = (char *)malloc(strlen(resolved) + 1);
    if (!root) { fputs("OOM\n", stderr); exit(1); }
    strcpy(root, resolved);
    return root;
#endif
}

char *resolve_document(const char *relative) {
    char *root = resolve_workspace_root();
    /* path = root + PATH_SEP + "test_documents" + PATH_SEP + relative */
    size_t len = strlen(root) + 1 + strlen("test_documents") + 1 + strlen(relative) + 1;
    char *path = (char *)malloc(len);
    if (!path) { fputs("OOM\n", stderr); exit(1); }
    snprintf(path, len, "%s" PATH_SEP "test_documents" PATH_SEP "%s", root, relative);
    free(root);
    return path;
}

char *ensure_document(const char *relative, int skip_if_missing) {
    char *path = resolve_document(relative);
    struct stat st;
    if (stat(path, &st) != 0) {
        if (skip_if_missing) {
            printf("SKIP: document not found: %s\n", path);
            free(path);
            return NULL;
        }
        fprintf(stderr, "FAIL: document unavailable: %s\n", path);
        free(path);
        exit(1);
    }
    return path;
}

ExtractionConfig *build_config(const char *json_str) {
    if (!json_str) return NULL;
    ExtractionConfig *cfg = kreuzberg_config_from_json(json_str);
    if (!cfg) {
        const char *err = kreuzberg_last_error();
        fprintf(stderr, "FAIL: could not parse config JSON: %s\n",
                err ? err : "(unknown error)");
        exit(1);
    }
    return cfg;
}

/* ---- extraction helpers -------------------------------------------------- */

int should_skip_missing_dependency(const CExtractionResult *result) {
    if (!result) return 0;
    if (result->success) return 0;
    /* Walk through all potential error-message fields */
    const char *sources[] = {
        result->content,   /* sometimes populated on error */
        kreuzberg_last_error(),
        NULL
    };
    for (int i = 0; sources[i]; i++) {
        if (str_contains_ci(sources[i], "missing dependency")) return 1;
        if (str_contains_ci(sources[i], "missing_dependency")) return 1;
    }
    return 0;
}

CExtractionResult *run_extraction(const char *relative, const char *config_json) {
    char *path = ensure_document(relative, 1);
    if (!path) return NULL; /* document missing – caller should return */

    CExtractionResult *result;
    if (config_json) {
        result = kreuzberg_extract_file_sync_with_config(path, config_json);
    } else {
        result = kreuzberg_extract_file_sync(path);
    }
    free(path);

    if (!result) {
        const char *err = kreuzberg_last_error();
        fprintf(stderr, "FAIL: extraction returned NULL for %s: %s\n",
                relative, err ? err : "(unknown error)");
        exit(1);
    }
    if (!result->success) {
        if (should_skip_missing_dependency(result)) {
            printf("SKIP: missing dependency for %s\n", relative);
            kreuzberg_free_result(result);
            return NULL;
        }
        fprintf(stderr, "FAIL: extraction failed for %s\n", relative);
        kreuzberg_free_result(result);
        exit(1);
    }
    return result;
}

CExtractionResult *run_extraction_bytes(const char *relative, const char *config_json) {
    char *path = ensure_document(relative, 1);
    if (!path) return NULL;

    /* Read the file into memory */
    FILE *fp = fopen(path, "rb");
    if (!fp) {
        fprintf(stderr, "FAIL: cannot open %s\n", path);
        free(path);
        exit(1);
    }
    fseek(fp, 0, SEEK_END);
    long file_size = ftell(fp);
    rewind(fp);
    unsigned char *data = (unsigned char *)malloc((size_t)file_size);
    if (!data) { fputs("OOM\n", stderr); exit(1); }
    fread(data, 1, (size_t)file_size, fp);
    fclose(fp);

    /* Detect MIME type from path */
    char *mime = kreuzberg_detect_mime_type_from_path(path);
    if (!mime) {
        fprintf(stderr, "FAIL: could not detect MIME for %s\n", path);
        free(data);
        free(path);
        exit(1);
    }

    CExtractionResult *result;
    if (config_json) {
        result = kreuzberg_extract_bytes_sync_with_config(
            data, (size_t)file_size, mime, config_json);
    } else {
        result = kreuzberg_extract_bytes_sync(data, (size_t)file_size, mime);
    }

    kreuzberg_free_string(mime);
    free(data);
    free(path);

    if (!result) {
        const char *err = kreuzberg_last_error();
        fprintf(stderr, "FAIL: bytes extraction returned NULL for %s: %s\n",
                relative, err ? err : "(unknown error)");
        exit(1);
    }
    if (!result->success) {
        if (should_skip_missing_dependency(result)) {
            printf("SKIP: missing dependency for %s\n", relative);
            kreuzberg_free_result(result);
            return NULL;
        }
        fprintf(stderr, "FAIL: bytes extraction failed for %s\n", relative);
        kreuzberg_free_result(result);
        exit(1);
    }
    return result;
}

/* ---- feature skip ------------------------------------------------------- */

int skip_if_feature_unavailable(const char *feature) {
    /* Build env-var name: KREUZBERG_{UPPER_FEATURE}_AVAILABLE */
    char upper_feature[128];
    size_t feat_len = strlen(feature);
    size_t copy_len = feat_len < sizeof(upper_feature) - 1 ? feat_len : sizeof(upper_feature) - 1;
    for (size_t i = 0; i < copy_len; i++) {
        char ch = feature[i];
        upper_feature[i] = (ch == '-') ? '_' : (char)toupper((unsigned char)ch);
    }
    upper_feature[copy_len] = '\0';
    char env_var[256];
    snprintf(env_var, sizeof(env_var), "KREUZBERG_%s_AVAILABLE", upper_feature);

    const char *flag = getenv(env_var);
    if (!flag || strcmp(flag, "0") == 0 || strcasecmp(flag, "false") == 0) {
        printf("SKIP: feature \"%s\" not available (set %s=1 to enable)\n",
               feature, env_var);
        return 1;
    }
    return 0;
}

/* ---- string utilities --------------------------------------------------- */

int str_contains_ci(const char *haystack, const char *needle) {
    if (!haystack || !needle) return 0;
    size_t hlen = strlen(haystack);
    size_t nlen = strlen(needle);
    if (nlen == 0) return 1;
    if (nlen > hlen) return 0;
    for (size_t i = 0; i <= hlen - nlen; i++) {
        size_t j;
        for (j = 0; j < nlen; j++) {
            if (tolower((unsigned char)haystack[i + j]) != tolower((unsigned char)needle[j]))
                break;
        }
        if (j == nlen) return 1;
    }
    return 0;
}

size_t json_array_count(const char *json) {
    if (!json) return 0;
    /* Skip leading whitespace */
    while (*json && isspace((unsigned char)*json)) json++;
    if (*json != '[') return 0;
    json++; /* skip '[' */
    /* Skip trailing whitespace after '[' */
    while (*json && isspace((unsigned char)*json)) json++;
    if (*json == ']') return 0; /* empty array */

    /* Count top-level commas (depth 0 commas) */
    size_t count  = 1;
    int    depth  = 0;
    int    in_str = 0;
    char   prev   = 0;
    for (; *json && !(*json == ']' && depth == 0 && !in_str); json++) {
        char c = *json;
        if (in_str) {
            if (c == '"' && prev != '\\') in_str = 0;
        } else {
            if (c == '"') {
                in_str = 1;
            } else if (c == '[' || c == '{') {
                depth++;
            } else if (c == ']' || c == '}') {
                depth--;
            } else if (c == ',' && depth == 0) {
                count++;
            }
        }
        prev = c;
    }
    return count;
}

/* ---- assertion implementations ------------------------------------------ */

void assert_expected_mime(const CExtractionResult *result,
                          const char *const *mimes, size_t count) {
    if (!count) return;
    const char *actual = result->mime_type ? result->mime_type : "";
    for (size_t i = 0; i < count; i++) {
        if (str_contains_ci(actual, mimes[i])) return;
    }
    fprintf(stderr, "FAIL: expected MIME to match one of [");
    for (size_t i = 0; i < count; i++) {
        fprintf(stderr, "%s\"%s\"", i ? ", " : "", mimes[i]);
    }
    fprintf(stderr, "], got \"%s\"\n", actual);
    exit(1);
}

void assert_min_content_length(const CExtractionResult *result, size_t min) {
    size_t len = result->content ? strlen(result->content) : 0;
    if (len < min) {
        fprintf(stderr,
                "FAIL: expected content length >= %zu, got %zu\n", min, len);
        exit(1);
    }
}

void assert_max_content_length(const CExtractionResult *result, size_t max) {
    size_t len = result->content ? strlen(result->content) : 0;
    if (len > max) {
        fprintf(stderr,
                "FAIL: expected content length <= %zu, got %zu\n", max, len);
        exit(1);
    }
}

void assert_content_contains_any(const CExtractionResult *result,
                                 const char *const *snippets, size_t count) {
    if (!count) return;
    const char *content = result->content ? result->content : "";
    for (size_t i = 0; i < count; i++) {
        if (str_contains_ci(content, snippets[i])) return;
    }
    fprintf(stderr, "FAIL: expected content to contain any of [");
    for (size_t i = 0; i < count; i++) {
        fprintf(stderr, "%s\"%s\"", i ? ", " : "", snippets[i]);
    }
    fprintf(stderr, "]\n");
    exit(1);
}

void assert_content_contains_all(const CExtractionResult *result,
                                 const char *const *snippets, size_t count) {
    if (!count) return;
    const char *content = result->content ? result->content : "";
    for (size_t i = 0; i < count; i++) {
        if (!str_contains_ci(content, snippets[i])) {
            fprintf(stderr,
                    "FAIL: expected content to contain \"%s\"\n", snippets[i]);
            exit(1);
        }
    }
}

void assert_content_not_empty(const CExtractionResult *result) {
    size_t len = result->content ? strlen(result->content) : 0;
    if (!len) {
        fputs("FAIL: expected content to be non-empty\n", stderr);
        exit(1);
    }
}

void assert_table_count(const CExtractionResult *result,
                        int has_min, size_t min,
                        int has_max, size_t max) {
    size_t count = json_array_count(result->tables_json);
    if (has_min && count < min) {
        fprintf(stderr,
                "FAIL: expected at least %zu tables, found %zu\n", min, count);
        exit(1);
    }
    if (has_max && count > max) {
        fprintf(stderr,
                "FAIL: expected at most %zu tables, found %zu\n", max, count);
        exit(1);
    }
}

void assert_detected_languages(const CExtractionResult *result,
                               const char *const *expected, size_t count) {
    if (!count) return;
    const char *langs_json = result->detected_languages_json;
    if (!langs_json || strlen(langs_json) == 0) {
        fputs("FAIL: detected_languages_json is NULL or empty\n", stderr);
        exit(1);
    }
    for (size_t i = 0; i < count; i++) {
        if (!str_contains_ci(langs_json, expected[i])) {
            fprintf(stderr,
                    "FAIL: expected language \"%s\" not found in detected languages JSON\n",
                    expected[i]);
            exit(1);
        }
    }
}

void assert_chunks(const CExtractionResult *result,
                   int has_min, size_t min_count,
                   int has_max, size_t max_count) {
    size_t count = json_array_count(result->chunks_json);
    if (has_min && count < min_count) {
        fprintf(stderr,
                "FAIL: expected at least %zu chunks, found %zu\n",
                min_count, count);
        exit(1);
    }
    if (has_max && count > max_count) {
        fprintf(stderr,
                "FAIL: expected at most %zu chunks, found %zu\n",
                max_count, count);
        exit(1);
    }
}

void assert_images(const CExtractionResult *result,
                   int has_min, size_t min_count,
                   int has_max, size_t max_count) {
    size_t count = json_array_count(result->images_json);
    if (has_min && count < min_count) {
        fprintf(stderr,
                "FAIL: expected at least %zu images, found %zu\n",
                min_count, count);
        exit(1);
    }
    if (has_max && count > max_count) {
        fprintf(stderr,
                "FAIL: expected at most %zu images, found %zu\n",
                max_count, count);
        exit(1);
    }
}

void assert_pages(const CExtractionResult *result,
                  int has_min, size_t min_count,
                  int has_exact, size_t exact_count) {
    size_t count = json_array_count(result->pages_json);
    if (has_min && count < min_count) {
        fprintf(stderr,
                "FAIL: expected at least %zu pages, found %zu\n",
                min_count, count);
        exit(1);
    }
    if (has_exact && count != exact_count) {
        fprintf(stderr,
                "FAIL: expected exactly %zu pages, found %zu\n",
                exact_count, count);
        exit(1);
    }
}

void assert_elements(const CExtractionResult *result,
                     int has_min, size_t min_count) {
    size_t count = json_array_count(result->elements_json);
    if (has_min && count < min_count) {
        fprintf(stderr,
                "FAIL: expected at least %zu elements, found %zu\n",
                min_count, count);
        exit(1);
    }
}

void assert_ocr_elements(const CExtractionResult *result,
                         int has_elements,
                         int has_geometry,
                         int has_confidence,
                         int has_min, size_t min_count) {
    size_t count = json_array_count(result->ocr_elements_json);
    (void)has_geometry;
    (void)has_confidence;
    if (has_elements && count == 0) {
        fputs("FAIL: expected OCR elements but none found\n", stderr);
        exit(1);
    }
    if (has_min && count < min_count) {
        fprintf(stderr,
                "FAIL: expected at least %zu OCR elements, found %zu\n",
                min_count, count);
        exit(1);
    }
}

void assert_document(const CExtractionResult *result,
                     int has_document,
                     int has_min_node_count, size_t min_node_count) {
    const char *doc_json = result->document_json;
    if (has_document) {
        if (!doc_json || strlen(doc_json) == 0 || strcmp(doc_json, "null") == 0) {
            fputs("FAIL: expected document structure but document_json is empty\n", stderr);
            exit(1);
        }
        if (has_min_node_count) {
            /* Count "node_type" occurrences as a proxy for node count */
            size_t occurrences = 0;
            const char *p = doc_json;
            while ((p = strstr(p, "\"node_type\"")) != NULL) {
                occurrences++;
                p++;
            }
            if (occurrences < min_node_count) {
                fprintf(stderr,
                        "FAIL: expected at least %zu document nodes, found ~%zu\n",
                        min_node_count, occurrences);
                exit(1);
            }
        }
    } else {
        if (doc_json && strlen(doc_json) > 0 && strcmp(doc_json, "null") != 0) {
            fputs("FAIL: expected no document but document_json is present\n", stderr);
            exit(1);
        }
    }
}

void assert_keywords(const CExtractionResult *result,
                     int has_kw, int kw_present,
                     int has_min, size_t min_count,
                     int has_max, size_t max_count) {
    size_t count = json_array_count(result->extracted_keywords_json);
    if (has_kw) {
        if (kw_present && count == 0) {
            fputs("FAIL: expected keywords but extracted_keywords_json is empty\n", stderr);
            exit(1);
        }
        if (!kw_present && count > 0) {
            fprintf(stderr,
                    "FAIL: expected no keywords but found %zu\n", count);
            exit(1);
        }
    }
    if (has_min && count < min_count) {
        fprintf(stderr,
                "FAIL: expected at least %zu keywords, found %zu\n",
                min_count, count);
        exit(1);
    }
    if (has_max && count > max_count) {
        fprintf(stderr,
                "FAIL: expected at most %zu keywords, found %zu\n",
                max_count, count);
        exit(1);
    }
}

void assert_quality_score(const CExtractionResult *result,
                          int has_score, int score_present,
                          int has_min, double min_score,
                          int has_max, double max_score) {
    const char *qs_json = result->quality_score_json;
    int present = (qs_json && strlen(qs_json) > 0 && strcmp(qs_json, "null") != 0);
    if (has_score && score_present && !present) {
        fputs("FAIL: expected quality_score to be present\n", stderr);
        exit(1);
    }
    if (present && (has_min || has_max)) {
        double score = atof(qs_json);
        if (has_min && score < min_score) {
            fprintf(stderr,
                    "FAIL: expected quality_score >= %f, got %f\n",
                    min_score, score);
            exit(1);
        }
        if (has_max && score > max_score) {
            fprintf(stderr,
                    "FAIL: expected quality_score <= %f, got %f\n",
                    max_score, score);
            exit(1);
        }
    }
}

void assert_processing_warnings(const CExtractionResult *result,
                                int has_max, size_t max_count,
                                int has_is_empty, int is_empty) {
    size_t count = json_array_count(result->processing_warnings_json);
    if (has_is_empty && is_empty && count != 0) {
        fprintf(stderr,
                "FAIL: expected processing warnings to be empty, got %zu\n",
                count);
        exit(1);
    }
    if (has_max && count > max_count) {
        fprintf(stderr,
                "FAIL: expected at most %zu processing warnings, got %zu\n",
                max_count, count);
        exit(1);
    }
}

void assert_djot_content(const CExtractionResult *result,
                         int has_content, int content_present,
                         int has_min_blocks, size_t min_blocks) {
    /* djot_content_json maps to document_json as a proxy (not a dedicated field in C FFI) */
    /* We check document_json as djot serialisation is embedded there */
    const char *djot = result->document_json;
    int present = (djot && strlen(djot) > 0 && strcmp(djot, "null") != 0);
    if (has_content && content_present && !present) {
        fputs("FAIL: expected djot content to be present\n", stderr);
        exit(1);
    }
    if (present && has_min_blocks) {
        /* Count "type" keys as a proxy for block count */
        size_t block_count = 0;
        const char *p = djot;
        while ((p = strstr(p, "\"type\"")) != NULL) {
            block_count++;
            p++;
        }
        if (block_count < min_blocks) {
            fprintf(stderr,
                    "FAIL: expected at least %zu djot blocks, found ~%zu\n",
                    min_blocks, block_count);
            exit(1);
        }
    }
}

void assert_annotations(const CExtractionResult *result,
                        int has_annotations,
                        int has_min, size_t min_count) {
    size_t count = json_array_count(result->annotations_json);
    if (has_annotations && count == 0) {
        fputs("FAIL: expected annotations but annotations_json is empty\n", stderr);
        exit(1);
    }
    if (has_min && count < min_count) {
        fprintf(stderr,
                "FAIL: expected at least %zu annotations, found %zu\n",
                min_count, count);
        exit(1);
    }
}
