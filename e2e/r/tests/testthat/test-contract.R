# Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
# To regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang r
#
# Tests for contract fixtures.
# nolint start

test_that("api_batch_bytes_async", {
  result <- run_fixture_with_method(
    "api_batch_bytes_async",
    "pdf/fake_memo.pdf",
    NULL,
    "batch_async",
    "bytes",
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_content_contains_any(result, c("May 5, 2023", "Mallori"))
})

test_that("api_batch_bytes_sync", {
  result <- run_fixture_with_method(
    "api_batch_bytes_sync",
    "pdf/fake_memo.pdf",
    NULL,
    "batch_sync",
    "bytes",
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_content_contains_any(result, c("May 5, 2023", "Mallori"))
})

test_that("api_batch_file_async", {
  result <- run_fixture_with_method(
    "api_batch_file_async",
    "pdf/fake_memo.pdf",
    NULL,
    "batch_async",
    "file",
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_content_contains_any(result, c("May 5, 2023", "Mallori"))
})

test_that("api_batch_file_sync", {
  result <- run_fixture_with_method(
    "api_batch_file_sync",
    "pdf/fake_memo.pdf",
    NULL,
    "batch_sync",
    "file",
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_content_contains_any(result, c("May 5, 2023", "Mallori"))
})

test_that("api_extract_bytes_async", {
  result <- run_fixture_with_method(
    "api_extract_bytes_async",
    "pdf/fake_memo.pdf",
    NULL,
    "async",
    "bytes",
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_content_contains_any(result, c("May 5, 2023", "Mallori"))
})

test_that("api_extract_bytes_sync", {
  result <- run_fixture_with_method(
    "api_extract_bytes_sync",
    "pdf/fake_memo.pdf",
    NULL,
    "sync",
    "bytes",
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_content_contains_any(result, c("May 5, 2023", "Mallori"))
})

test_that("api_extract_file_async", {
  result <- run_fixture_with_method(
    "api_extract_file_async",
    "pdf/fake_memo.pdf",
    NULL,
    "async",
    "file",
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_content_contains_any(result, c("May 5, 2023", "Mallori"))
})

test_that("api_extract_file_sync", {
  result <- run_fixture(
    "api_extract_file_sync",
    "pdf/fake_memo.pdf",
    NULL,
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_content_contains_any(result, c("May 5, 2023", "Mallori"))
})

test_that("config_chunking", {
  result <- run_fixture(
    "config_chunking",
    "pdf/fake_memo.pdf",
    list(chunking = list(max_chars = 500L, max_overlap = 50L)),
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_chunks(result, min_count = 1L, each_has_content = TRUE)
})

test_that("config_chunking_markdown", {
  skip_if_feature_unavailable("chunking")
  result <- run_fixture(
    "config_chunking_markdown",
    "pdf/fake_memo.pdf",
    list(chunking = list(chunker_type = "markdown", max_chars = 500L, max_overlap = 50L)),
    requirements = c("chunking"),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_chunks(result, min_count = 1L, each_has_content = TRUE)
})

test_that("config_chunking_small", {
  skip_if_feature_unavailable("chunking")
  result <- run_fixture(
    "config_chunking_small",
    "pdf/fake_memo.pdf",
    list(chunking = list(max_chars = 100L, max_overlap = 20L)),
    requirements = c("chunking"),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_chunks(result, min_count = 2L, each_has_content = TRUE)
})

test_that("config_djot_content", {
  skip_if_feature_unavailable("pdf")
  result <- run_fixture(
    "config_djot_content",
    "pdf/fake_memo.pdf",
    list(output_format = "djot"),
    requirements = c("pdf"),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
})

test_that("config_document_structure", {
  result <- run_fixture(
    "config_document_structure",
    "pdf/fake_memo.pdf",
    list(include_document_structure = TRUE),
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_document(result, has_document = TRUE, min_node_count = 1L, node_types_include = c("paragraph"))
})

test_that("config_document_structure_disabled", {
  result <- run_fixture(
    "config_document_structure_disabled",
    "pdf/fake_memo.pdf",
    NULL,
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_document(result, has_document = FALSE)
})

test_that("config_document_structure_headings", {
  skip_if_feature_unavailable("office")
  result <- run_fixture(
    "config_document_structure_headings",
    "docx/unit_test_headers.docx",
    list(include_document_structure = TRUE),
    requirements = c("office"),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/vnd.openxmlformats-officedocument.wordprocessingml.document"))
  assert_document(result, has_document = TRUE, min_node_count = 1L, node_types_include = c("heading", "paragraph"))
})

test_that("config_document_structure_with_headings", {
  result <- run_fixture(
    "config_document_structure_with_headings",
    "docx/fake.docx",
    list(include_document_structure = TRUE),
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/vnd.openxmlformats-officedocument.wordprocessingml.document"))
  assert_document(result, has_document = TRUE, min_node_count = 1L)
})

test_that("config_element_types", {
  skip_if_feature_unavailable("office")
  result <- run_fixture(
    "config_element_types",
    "docx/unit_test_headers.docx",
    list(result_format = "element_based"),
    requirements = c("office"),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/vnd.openxmlformats-officedocument.wordprocessingml.document"))
  assert_elements(result, min_count = 1L, types_include = c("narrative_text"))
})

test_that("config_force_ocr", {
  skip_if_feature_unavailable("tesseract")
  result <- run_fixture(
    "config_force_ocr",
    "pdf/fake_memo.pdf",
    list(force_ocr = TRUE),
    requirements = c("tesseract"),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 5L)
})

test_that("config_html_options", {
  result <- run_fixture(
    "config_html_options",
    "html/complex_table.html",
    list(html_options = list(include_links = TRUE)),
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("text/html"))
  assert_min_content_length(result, 10L)
  assert_content_not_empty(result)
})

test_that("config_images", {
  result <- run_fixture(
    "config_images",
    "pdf/embedded_images_tables.pdf",
    list(images = list(extract_images = TRUE)),
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_images(result, min_count = 1L)
})

test_that("config_keywords", {
  skip_if_feature_unavailable("keywords-yake")
  result <- run_fixture(
    "config_keywords",
    "pdf/fake_memo.pdf",
    list(keywords = list(algorithm = "yake", max_keywords = 10L)),
    requirements = c("keywords-yake"),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_keywords(result, has_keywords = TRUE, min_count = 1L)
})

test_that("config_language_detection", {
  result <- run_fixture(
    "config_language_detection",
    "pdf/fake_memo.pdf",
    list(language_detection = list(enabled = TRUE)),
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_detected_languages(result, c("eng"), 0.5)
})

test_that("config_language_multi", {
  skip_if_feature_unavailable("language-detection")
  result <- run_fixture(
    "config_language_multi",
    "pdf/fake_memo.pdf",
    list(language_detection = list(detect_multiple = TRUE, enabled = TRUE)),
    requirements = c("language-detection"),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_detected_languages(result, c("eng"), NULL)
})

test_that("config_pages", {
  skip_if_feature_unavailable("pdf")
  result <- run_fixture(
    "config_pages",
    "pdf/fake_memo.pdf",
    list(pages = list(extract_pages = TRUE, insert_page_markers = TRUE)),
    requirements = c("pdf"),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_content_contains_any(result, c("PAGE"))
})

test_that("config_pages_extract", {
  skip_if_feature_unavailable("pdf")
  result <- run_fixture(
    "config_pages_extract",
    "pdf/fake_memo.pdf",
    list(pages = list(extract_pages = TRUE)),
    requirements = c("pdf"),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_pages(result, min_count = 1L)
})

test_that("config_pages_markers", {
  skip_if_feature_unavailable("pdf")
  result <- run_fixture(
    "config_pages_markers",
    "pdf/fake_memo.pdf",
    list(pages = list(insert_page_markers = TRUE)),
    requirements = c("pdf"),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_content_contains_any(result, c("PAGE"))
})

test_that("config_pdf_hierarchy", {
  skip_if_feature_unavailable("pdf")
  result <- run_fixture(
    "config_pdf_hierarchy",
    "pdf/fake_memo.pdf",
    list(pages = list(extract_pages = TRUE), pdf_options = list(hierarchy = list(enabled = TRUE, include_bbox = TRUE))),
    requirements = c("pdf"),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 50L)
})

test_that("config_postprocessor", {
  result <- run_fixture(
    "config_postprocessor",
    "pdf/fake_memo.pdf",
    list(postprocessor = list(enabled = TRUE)),
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_content_not_empty(result)
})

test_that("config_quality_disabled", {
  result <- run_fixture(
    "config_quality_disabled",
    "pdf/fake_memo.pdf",
    list(enable_quality_processing = FALSE),
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_content_not_empty(result)
})

test_that("config_quality_enabled", {
  skip_if_feature_unavailable("quality")
  result <- run_fixture(
    "config_quality_enabled",
    "pdf/fake_memo.pdf",
    list(enable_quality_processing = TRUE),
    requirements = c("quality"),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
  assert_quality_score(result, has_score = TRUE, min_score = 0, max_score = 1)
})

test_that("config_structured_output", {
  skip_if_feature_unavailable("pdf")
  result <- run_fixture(
    "config_structured_output",
    "pdf/fake_memo.pdf",
    list(output_format = "structured"),
    requirements = c("pdf"),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
})

test_that("config_use_cache_false", {
  result <- run_fixture(
    "config_use_cache_false",
    "pdf/fake_memo.pdf",
    list(use_cache = FALSE),
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
})

test_that("output_format_bytes_markdown", {
  result <- run_fixture_with_method(
    "output_format_bytes_markdown",
    "pdf/fake_memo.pdf",
    list(output_format = "markdown"),
    "sync",
    "bytes",
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
})

test_that("output_format_djot", {
  result <- run_fixture(
    "output_format_djot",
    "pdf/fake_memo.pdf",
    list(output_format = "djot"),
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
})

test_that("output_format_html", {
  result <- run_fixture(
    "output_format_html",
    "pdf/fake_memo.pdf",
    list(output_format = "html"),
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
})

test_that("output_format_markdown", {
  result <- run_fixture(
    "output_format_markdown",
    "pdf/fake_memo.pdf",
    list(output_format = "markdown"),
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
})

test_that("output_format_plain", {
  result <- run_fixture(
    "output_format_plain",
    "pdf/fake_memo.pdf",
    list(output_format = "plain"),
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
})

test_that("result_format_element_based", {
  result <- run_fixture(
    "result_format_element_based",
    "pdf/fake_memo.pdf",
    list(result_format = "element_based"),
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_elements(result, min_count = 1L)
})

test_that("result_format_unified", {
  result <- run_fixture(
    "result_format_unified",
    "pdf/fake_memo.pdf",
    list(result_format = "unified"),
    requirements = character(0),
    notes = NULL,
    skip_if_missing = TRUE
  )
  assert_expected_mime(result, c("application/pdf"))
  assert_min_content_length(result, 10L)
})
# nolint end
