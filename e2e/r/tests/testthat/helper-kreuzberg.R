# Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
# To regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang r
# nolint start

library(kreuzberg)

WORKSPACE_ROOT <- normalizePath(file.path(dirname(sys.frame(1)$ofile %||% "."), "..", "..", ".."), mustWork = FALSE)
TEST_DOCUMENTS <- file.path(WORKSPACE_ROOT, "test_documents")

resolve_document <- function(relative) {
  file.path(TEST_DOCUMENTS, relative)
}

build_config <- function(raw) {
  if (is.null(raw) || length(raw) == 0) {
    return(NULL)
  }
  raw
}

build_extraction_config <- function(raw) {
  if (is.null(raw) || length(raw) == 0) {
    return(NULL)
  }
  # Convert the raw config map into extraction_config() call
  do.call(extraction_config, raw)
}

skip_reason_for <- function(error, fixture_id, requirements, notes = NULL) {
  message <- conditionMessage(error)
  downcased <- tolower(message)
  requirement_hit <- any(vapply(requirements, function(req) grepl(tolower(req), downcased, fixed = TRUE), logical(1)))
  missing_dependency <- grepl("missing dependency", downcased, fixed = TRUE)
  unsupported_format <- grepl("unsupported format", downcased, fixed = TRUE)

  if (!missing_dependency && !unsupported_format && !requirement_hit) {
    return(NULL)
  }

  reason <- if (missing_dependency) {
    "missing dependency"
  } else if (unsupported_format) {
    "unsupported format"
  } else if (length(requirements) > 0) {
    paste0("requires ", paste(requirements, collapse = ", "))
  } else {
    "environmental requirement"
  }

  details <- paste0("Skipping ", fixture_id, ": ", reason, ". ", class(error)[1], ": ", message)
  if (!is.null(notes)) details <- paste0(details, " Notes: ", notes)
  message(details)
  details
}

skip_if_feature_unavailable <- function(feature) {
  env_var <- paste0("KREUZBERG_", toupper(gsub("-", "_", feature)), "_AVAILABLE")
  flag <- Sys.getenv(env_var, unset = "")
  if (flag == "" || flag == "0" || tolower(flag) == "false") {
    testthat::skip(paste0("Feature ", feature, " not available (set ", env_var, "=1)"))
  }
}

run_fixture <- function(fixture_id, relative_path, config_hash, requirements, notes, skip_if_missing = TRUE) {
  run_fixture_with_method(fixture_id, relative_path, config_hash, "sync", "file",
    requirements = requirements, notes = notes, skip_if_missing = skip_if_missing
  )
}

run_fixture_with_method <- function(fixture_id, relative_path, config_hash, method, input_type,
                                    requirements, notes, skip_if_missing = TRUE) {
  document_path <- resolve_document(relative_path)

  if (skip_if_missing && !file.exists(document_path)) {
    testthat::skip(paste0("missing document at ", document_path))
  }

  config <- build_config(config_hash)

  result <- tryCatch(
    perform_extraction(document_path, config, method, input_type),
    error = function(e) {
      reason <- skip_reason_for(e, fixture_id, requirements, notes)
      if (!is.null(reason)) {
        testthat::skip(reason)
      }
      stop(e)
    }
  )

  result
}

perform_extraction <- function(document_path, config, method, input_type) {
  mime_type <- detect_mime_type_from_path(document_path)
  if (method == "sync" && input_type == "file") {
    extract_file_sync(document_path, config = config)
  } else if (method == "sync" && input_type == "bytes") {
    bytes <- readBin(document_path, "raw", file.info(document_path)$size)
    extract_bytes_sync(bytes, mime_type, config = config)
  } else if (method == "async" && input_type == "file") {
    extract_file(document_path, config = config)
  } else if (method == "async" && input_type == "bytes") {
    bytes <- readBin(document_path, "raw", file.info(document_path)$size)
    extract_bytes(bytes, mime_type, config = config)
  } else if (method == "batch_sync" && input_type == "file") {
    results <- batch_extract_files_sync(list(document_path), config = config)
    results[[1]]
  } else if (method == "batch_sync" && input_type == "bytes") {
    bytes <- readBin(document_path, "raw", file.info(document_path)$size)
    results <- batch_extract_bytes_sync(list(bytes), list(mime_type), config = config)
    results[[1]]
  } else if (method == "batch_async" && input_type == "file") {
    results <- batch_extract_files(list(document_path), config = config)
    results[[1]]
  } else if (method == "batch_async" && input_type == "bytes") {
    bytes <- readBin(document_path, "raw", file.info(document_path)$size)
    results <- batch_extract_bytes(list(bytes), list(mime_type), config = config)
    results[[1]]
  } else {
    stop(paste0("Unknown extraction method/input_type combo: ", method, "/", input_type))
  }
}

# Assertion helpers
assert_expected_mime <- function(result, expected) {
  if (length(expected) == 0) {
    return(invisible(NULL))
  }
  testthat::expect_true(any(vapply(expected, function(token) grepl(token, result$mime_type, fixed = TRUE), logical(1))))
}

assert_min_content_length <- function(result, minimum) {
  testthat::expect_gte(nchar(result$content), minimum)
}

assert_max_content_length <- function(result, maximum) {
  testthat::expect_lte(nchar(result$content), maximum)
}

assert_content_contains_any <- function(result, snippets) {
  if (length(snippets) == 0) {
    return(invisible(NULL))
  }
  lowered <- tolower(result$content)
  testthat::expect_true(any(vapply(snippets, function(s) grepl(tolower(s), lowered, fixed = TRUE), logical(1))))
}

assert_content_contains_all <- function(result, snippets) {
  if (length(snippets) == 0) {
    return(invisible(NULL))
  }
  lowered <- tolower(result$content)
  testthat::expect_true(all(vapply(snippets, function(s) grepl(tolower(s), lowered, fixed = TRUE), logical(1))))
}

assert_table_count <- function(result, minimum = NULL, maximum = NULL) {
  tables <- if (is.null(result$tables)) list() else result$tables
  if (!is.null(minimum)) testthat::expect_gte(length(tables), minimum)
  if (!is.null(maximum)) testthat::expect_lte(length(tables), maximum)
}

assert_detected_languages <- function(result, expected, min_confidence = NULL) {
  if (length(expected) == 0) {
    return(invisible(NULL))
  }
  languages <- result$detected_languages
  testthat::expect_false(is.null(languages))
  testthat::expect_true(all(expected %in% languages))
  if (!is.null(min_confidence)) {
    metadata <- result$metadata
    if (!is.null(metadata)) {
      confidence <- metadata$confidence
      if (!is.null(confidence)) {
        testthat::expect_gte(as.numeric(confidence), min_confidence)
      }
    }
  }
}

assert_metadata_expectation <- function(result, path, expectation) {
  metadata <- if (is.null(result$metadata)) list() else result$metadata
  value <- fetch_metadata_value(metadata, path)
  if (is.null(value)) stop(paste0("Metadata path '", path, "' missing"))

  if (!is.list(expectation)) {
    testthat::expect_true(values_equal(value, expectation))
    return(invisible(NULL))
  }

  if (!is.null(expectation$eq)) {
    testthat::expect_true(values_equal(value, expectation$eq))
  }
  if (!is.null(expectation$gte)) {
    testthat::expect_gte(as.numeric(value), as.numeric(expectation$gte))
  }
  if (!is.null(expectation$lte)) {
    testthat::expect_lte(as.numeric(value), as.numeric(expectation$lte))
  }
  if (!is.null(expectation$contains)) {
    contains <- expectation$contains
    if (is.character(value) && is.character(contains)) {
      testthat::expect_true(grepl(contains, value, fixed = TRUE))
    } else if (is.list(value) && is.character(contains)) {
      testthat::expect_true(contains %in% unlist(value))
    } else if (is.list(value) && is.list(contains)) {
      testthat::expect_true(all(unlist(contains) %in% unlist(value)))
    }
  }
}

assert_chunks <- function(result, min_count = NULL, max_count = NULL,
                          each_has_content = NULL, each_has_embedding = NULL) {
  chunks <- if (is.null(result$chunks)) list() else result$chunks
  if (!is.null(min_count)) testthat::expect_gte(length(chunks), min_count)
  if (!is.null(max_count)) testthat::expect_lte(length(chunks), max_count)
  if (isTRUE(each_has_content)) {
    for (chunk in chunks) testthat::expect_false(is.null(chunk$content))
  }
  if (isTRUE(each_has_embedding)) {
    for (chunk in chunks) testthat::expect_false(is.null(chunk$embedding))
  }
}

assert_images <- function(result, min_count = NULL, max_count = NULL, formats_include = NULL) {
  images <- if (is.null(result$images)) list() else result$images
  if (!is.null(min_count)) testthat::expect_gte(length(images), min_count)
  if (!is.null(max_count)) testthat::expect_lte(length(images), max_count)
  if (!is.null(formats_include)) {
    found_formats <- unique(vapply(images, function(img) img$format %||% "", character(1)))
    for (fmt in formats_include) {
      testthat::expect_true(fmt %in% found_formats)
    }
  }
}

assert_pages <- function(result, min_count = NULL, exact_count = NULL) {
  pages <- if (is.null(result$pages)) list() else result$pages
  if (!is.null(min_count)) testthat::expect_gte(length(pages), min_count)
  if (!is.null(exact_count)) testthat::expect_equal(length(pages), exact_count)
}

assert_elements <- function(result, min_count = NULL, types_include = NULL) {
  elements <- if (is.null(result$elements)) list() else result$elements
  if (!is.null(min_count)) testthat::expect_gte(length(elements), min_count)
  if (!is.null(types_include)) {
    found_types <- unique(vapply(elements, function(el) el$type %||% "", character(1)))
    for (t in types_include) {
      testthat::expect_true(t %in% found_types)
    }
  }
}

assert_ocr_elements <- function(result, has_elements = NULL, elements_have_geometry = NULL,
                                elements_have_confidence = NULL, min_count = NULL) {
  ocr_elements <- result$ocr_elements
  if (isTRUE(has_elements)) {
    testthat::expect_false(is.null(ocr_elements))
    testthat::expect_gt(length(ocr_elements), 0)
  }
  if (!is.list(ocr_elements)) {
    return(invisible(NULL))
  }
  if (!is.null(min_count)) testthat::expect_gte(length(ocr_elements), min_count)
  if (isTRUE(elements_have_geometry)) {
    for (el in ocr_elements) {
      testthat::expect_false(is.null(el$geometry))
      testthat::expect_true(el$geometry$type %in% c("rectangle", "quadrilateral"))
    }
  }
  if (isTRUE(elements_have_confidence)) {
    for (el in ocr_elements) {
      testthat::expect_false(is.null(el$confidence))
      testthat::expect_gt(el$confidence$recognition, 0)
    }
  }
}

assert_document <- function(result, has_document = FALSE, min_node_count = NULL,
                            node_types_include = NULL, has_groups = NULL) {
  document <- result$document
  if (has_document) {
    testthat::expect_false(is.null(document))
    nodes <- if (is.list(document) && !is.null(document$nodes)) document$nodes else document
    testthat::expect_false(is.null(nodes))
    if (!is.null(min_node_count)) testthat::expect_gte(length(nodes), min_node_count)
    if (!is.null(node_types_include)) {
      found_types <- unique(vapply(nodes, function(n) {
        c <- if (!is.null(n$content)) n$content else n
        if (is.list(c)) c$node_type %||% "" else ""
      }, character(1)))
      for (t in node_types_include) {
        testthat::expect_true(t %in% found_types)
      }
    }
    if (is.logical(has_groups)) {
      has_group_nodes <- any(vapply(nodes, function(n) {
        c <- if (!is.null(n$content)) n$content else n
        if (is.list(c)) identical(c$node_type, "group") else FALSE
      }, logical(1)))
      testthat::expect_equal(has_group_nodes, has_groups)
    }
  } else {
    testthat::expect_null(document)
  }
}

assert_keywords <- function(result, has_keywords = NULL, min_count = NULL, max_count = NULL) {
  keywords <- result$extracted_keywords
  if (isTRUE(has_keywords)) {
    testthat::expect_false(is.null(keywords))
    testthat::expect_true(is.character(keywords) || is.list(keywords))
    testthat::expect_gt(length(keywords), 0)
  }
  if (identical(has_keywords, FALSE)) {
    if (is.null(keywords)) {
      testthat::expect_null(keywords)
    } else {
      testthat::expect_length(keywords, 0)
    }
  }
  if (!is.null(keywords) && (is.character(keywords) || is.list(keywords))) {
    if (!is.null(min_count)) testthat::expect_gte(length(keywords), min_count)
    if (!is.null(max_count)) testthat::expect_lte(length(keywords), max_count)
  }
}

assert_content_not_empty <- function(result) {
  testthat::expect_false(is.null(result$content))
  testthat::expect_gt(nchar(result$content), 0)
}

assert_table_bounding_boxes <- function(result) {
  tables <- if (is.null(result$tables)) list() else result$tables
  for (table in tables) {
    testthat::expect_false(is.null(table$bounding_box))
  }
}

assert_table_content_contains_any <- function(result, snippets) {
  if (length(snippets) == 0) {
    return(invisible(NULL))
  }
  tables <- if (is.null(result$tables)) list() else result$tables
  all_content <- tolower(paste(vapply(tables, function(t) t$content %||% "", character(1)), collapse = " "))
  testthat::expect_true(any(vapply(snippets, function(s) grepl(tolower(s), all_content, fixed = TRUE), logical(1))))
}

assert_image_bounding_boxes <- function(result) {
  images <- if (is.null(result$images)) list() else result$images
  for (image in images) {
    testthat::expect_false(is.null(image$bounding_box))
  }
}

assert_quality_score <- function(result, has_score = NULL, min_score = NULL, max_score = NULL) {
  if (isTRUE(has_score)) testthat::expect_false(is.null(result$quality_score))
  if (!is.null(min_score) && !is.null(result$quality_score)) {
    testthat::expect_gte(result$quality_score, min_score)
  }
  if (!is.null(max_score) && !is.null(result$quality_score)) {
    testthat::expect_lte(result$quality_score, max_score)
  }
}

assert_processing_warnings <- function(result, max_count = NULL, is_empty = NULL) {
  warnings_list <- if (is.null(result$processing_warnings)) character(0) else result$processing_warnings
  if (isTRUE(is_empty)) testthat::expect_length(warnings_list, 0)
  if (!is.null(max_count)) testthat::expect_lte(length(warnings_list), max_count)
}

assert_djot_content <- function(result, has_content = NULL, min_blocks = NULL) {
  if (isTRUE(has_content)) {
    testthat::expect_false(is.null(result$djot_content))
    testthat::expect_gt(nchar(result$djot_content), 0)
  }
  if (!is.null(min_blocks) && !is.null(result$djot_content)) {
    blocks <- strsplit(result$djot_content, "\n\n")[[1]]
    testthat::expect_gte(length(blocks), min_blocks)
  }
}

assert_annotations <- function(result, has_annotations = FALSE, min_count = NULL) {
  annotations <- result$annotations
  if (has_annotations) {
    testthat::expect_false(is.null(annotations))
    testthat::expect_true(is.list(annotations))
    testthat::expect_gt(length(annotations), 0)
  }
  if (is.list(annotations) && !is.null(min_count)) {
    testthat::expect_gte(length(annotations), min_count)
  }
}

# Internal helpers
fetch_metadata_value <- function(metadata, path) {
  value <- lookup_metadata_path(metadata, path)
  if (!is.null(value)) {
    return(value)
  }
  format_data <- metadata$format
  if (is.list(format_data)) {
    return(lookup_metadata_path(format_data, path))
  }
  NULL
}

lookup_metadata_path <- function(metadata, path) {
  current <- metadata
  segments <- strsplit(path, ".", fixed = TRUE)[[1]]
  for (segment in segments) {
    if (!is.list(current)) {
      return(NULL)
    }
    current <- current[[segment]]
    if (is.null(current)) {
      return(NULL)
    }
  }
  current
}

values_equal <- function(lhs, rhs) {
  if (is.character(lhs) && is.character(rhs)) {
    return(identical(lhs, rhs))
  }
  if (is.numeric(lhs) && is.numeric(rhs)) {
    return(as.numeric(lhs) == as.numeric(rhs))
  }
  identical(lhs, rhs)
}

`%||%` <- function(x, y) if (is.null(x)) y else x
# nolint end
