// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
// To regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang wasm-deno

// Tests for pdf fixtures. Run with: deno test --allow-read

import type { ExtractionResult } from "./helpers.ts";
import { assertions, buildConfig, extractBytes, initWasm, resolveDocument, shouldSkipFixture } from "./helpers.ts";

// Initialize WASM module once at module load time
await initWasm();

Deno.test("pdf_annotations", { permissions: { read: true } }, async () => {
	const config = buildConfig({ pdf_options: { extract_annotations: true } });
	let result: ExtractionResult | null = null;
	try {
		const documentBytes = await resolveDocument("pdf/test_article.pdf");
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/pdf", config);
	} catch (error) {
		if (
			shouldSkipFixture(error, "pdf_annotations", [], "PDFium ARM Linux binary does not support annotation extraction")
		) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertAnnotations(result, true, 1);
});

Deno.test("pdf_assembly_technical", { permissions: { read: true } }, async () => {
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		const documentBytes = await resolveDocument("pdf/assembly_language_for_beginners_al4_b_en.pdf");
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/pdf", config);
	} catch (error) {
		if (shouldSkipFixture(error, "pdf_assembly_technical", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 5000);
	assertions.assertContentContainsAny(result, ["assembly", "register", "instruction"]);
	assertions.assertMetadataExpectation(result, "format_type", { eq: "pdf" });
});

Deno.test("pdf_bayesian_data_analysis", { permissions: { read: true } }, async () => {
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		const documentBytes = await resolveDocument("pdf/bayesian_data_analysis_third_edition_13th_feb_2020.pdf");
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/pdf", config);
	} catch (error) {
		if (shouldSkipFixture(error, "pdf_bayesian_data_analysis", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10000);
	assertions.assertContentContainsAny(result, ["Bayesian", "probability", "distribution"]);
	assertions.assertMetadataExpectation(result, "format_type", { eq: "pdf" });
});

Deno.test("pdf_bounding_boxes", { permissions: { read: true } }, async () => {
	const config = buildConfig({ images: { extract_images: true } });
	let result: ExtractionResult | null = null;
	try {
		const documentBytes = await resolveDocument("pdf/tiny.pdf");
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "pdf_bounding_boxes", ["pdf"], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 50);
	assertions.assertTableCount(result, 1, null);
	assertions.assertTableBoundingBoxes(result, true);
});

Deno.test("pdf_code_and_formula", { permissions: { read: true } }, async () => {
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		const documentBytes = await resolveDocument("pdf/code_and_formula.pdf");
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/pdf", config);
	} catch (error) {
		if (shouldSkipFixture(error, "pdf_code_and_formula", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 100);
});

Deno.test("pdf_deep_learning", { permissions: { read: true } }, async () => {
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		const documentBytes = await resolveDocument("pdf/fundamentals_of_deep_learning_2014.pdf");
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/pdf", config);
	} catch (error) {
		if (shouldSkipFixture(error, "pdf_deep_learning", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 1000);
	assertions.assertContentContainsAny(result, ["neural", "network", "deep learning"]);
	assertions.assertMetadataExpectation(result, "format_type", { eq: "pdf" });
});

Deno.test("pdf_embedded_images", { permissions: { read: true } }, async () => {
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		const documentBytes = await resolveDocument("pdf/embedded_images_tables.pdf");
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/pdf", config);
	} catch (error) {
		if (shouldSkipFixture(error, "pdf_embedded_images", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 50);
	assertions.assertTableCount(result, 0, null);
});

Deno.test("pdf_google_doc", { permissions: { read: true } }, async () => {
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		const documentBytes = await resolveDocument("pdf/google_doc_document.pdf");
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/pdf", config);
	} catch (error) {
		if (shouldSkipFixture(error, "pdf_google_doc", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 50);
	assertions.assertMetadataExpectation(result, "format_type", { eq: "pdf" });
});

Deno.test("pdf_large_ciml", { permissions: { read: true } }, async () => {
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		const documentBytes = await resolveDocument("pdf/a_course_in_machine_learning_ciml_v0_9_all.pdf");
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/pdf", config);
	} catch (error) {
		if (shouldSkipFixture(error, "pdf_large_ciml", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10000);
	assertions.assertContentContainsAny(result, ["machine learning", "algorithm", "training"]);
	assertions.assertMetadataExpectation(result, "format_type", { eq: "pdf" });
});

Deno.test("pdf_non_english_german", { permissions: { read: true } }, async () => {
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		const documentBytes = await resolveDocument("pdf/5_level_paging_and_5_level_ept_intel_revision_1_1_may_2017.pdf");
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/pdf", config);
	} catch (error) {
		if (shouldSkipFixture(error, "pdf_non_english_german", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 100);
	assertions.assertContentContainsAny(result, ["Intel", "paging"]);
	assertions.assertMetadataExpectation(result, "format_type", { eq: "pdf" });
});

Deno.test("pdf_right_to_left", { permissions: { read: true } }, async () => {
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		const documentBytes = await resolveDocument("pdf/right_to_left_01.pdf");
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/pdf", config);
	} catch (error) {
		if (shouldSkipFixture(error, "pdf_right_to_left", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 50);
	assertions.assertMetadataExpectation(result, "format_type", { eq: "pdf" });
});

Deno.test("pdf_simple_text", { permissions: { read: true } }, async () => {
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/pdf", config);
	} catch (error) {
		if (shouldSkipFixture(error, "pdf_simple_text", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 50);
	assertions.assertContentContainsAny(result, ["May 5, 2023", "To Whom it May Concern", "Mallori"]);
});

Deno.test("pdf_tables_large", { permissions: { read: true } }, async () => {
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		const documentBytes = await resolveDocument("pdf/large.pdf");
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/pdf", config);
	} catch (error) {
		if (shouldSkipFixture(error, "pdf_tables_large", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 500);
});

Deno.test("pdf_tables_medium", { permissions: { read: true } }, async () => {
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		const documentBytes = await resolveDocument("pdf/medium.pdf");
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/pdf", config);
	} catch (error) {
		if (shouldSkipFixture(error, "pdf_tables_medium", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 100);
});

Deno.test("pdf_tables_small", { permissions: { read: true } }, async () => {
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		const documentBytes = await resolveDocument("pdf/tiny.pdf");
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/pdf", config);
	} catch (error) {
		if (shouldSkipFixture(error, "pdf_tables_small", ["ocr"], "PDF table extraction requires OCR feature")) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 50);
	assertions.assertContentContainsAll(result, [
		"Table 1",
		"Selected Numbers",
		"Celsius",
		"Fahrenheit",
		"Water Freezing Point",
		"Water Boiling Point",
	]);
	// Table assertions require OCR feature for PDF table extraction
	if (result.tables.length > 0) {
		assertions.assertTableCount(result, 1, null);
	}
});

Deno.test("pdf_technical_stat_learning", { permissions: { read: true } }, async () => {
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		const documentBytes = await resolveDocument(
			"pdf/an_introduction_to_statistical_learning_with_applications_in_r_islr_sixth_printing.pdf",
		);
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/pdf", config);
	} catch (error) {
		if (shouldSkipFixture(error, "pdf_technical_stat_learning", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10000);
	assertions.assertContentContainsAny(result, ["statistical", "regression", "learning"]);
	assertions.assertMetadataExpectation(result, "format_type", { eq: "pdf" });
});
