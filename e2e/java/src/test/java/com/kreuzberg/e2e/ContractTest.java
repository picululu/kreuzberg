package com.kreuzberg.e2e;

// CHECKSTYLE.OFF: UnusedImports - generated code
// CHECKSTYLE.OFF: LineLength - generated code
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import dev.kreuzberg.BytesWithMime;
import dev.kreuzberg.ExtractionResult;
import dev.kreuzberg.Kreuzberg;
import dev.kreuzberg.config.ExtractionConfig;
import org.junit.jupiter.api.Test;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertTrue;
// CHECKSTYLE.ON: UnusedImports
// CHECKSTYLE.ON: LineLength

// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
// To regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang java

/** Tests for contract fixtures. */
public class ContractTest {
    private static final ObjectMapper MAPPER = new ObjectMapper();

    @Test
    public void apiBatchBytesAsync() throws Exception {
        JsonNode config = null;
        Path documentPath = E2EHelpers.resolveDocument("pdf/fake_memo.pdf");

        if (true && !Files.exists(documentPath)) {
            String msg = String.format("Skipping api_batch_bytes_async: missing document at %s", documentPath);
            System.err.println(msg);
            org.junit.jupiter.api.Assumptions.assumeTrue(false, msg);
            return;
        }

        byte[] documentBytes = Files.readAllBytes(documentPath);
        String mimeType = Kreuzberg.detectMimeType(documentBytes);
        ExtractionConfig extractionConfig = E2EHelpers.buildConfig(config);
        List<BytesWithMime> items = Arrays.asList(new BytesWithMime(documentBytes, mimeType));
        java.util.concurrent.CompletableFuture<List<ExtractionResult>> future = Kreuzberg.batchExtractBytesAsync(items, extractionConfig);
        List<ExtractionResult> results;
        try {
            results = future.get();
        } catch (java.util.concurrent.ExecutionException e) {
            Throwable cause = e.getCause() != null ? e.getCause() : e;
            if (cause instanceof Exception) {
                String skipReason = E2EHelpers.skipReasonFor((Exception) cause, "api_batch_bytes_async", Collections.emptyList(), null);
                if (skipReason != null) {
                    org.junit.jupiter.api.Assumptions.assumeTrue(false, skipReason);
                    return;
                }
            }
            throw e;
        }

        assertTrue(results.size() == 1, "Expected exactly 1 result from batch extraction");
        ExtractionResult result = results.get(0);

        E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
        E2EHelpers.Assertions.assertMinContentLength(result, 10);
        E2EHelpers.Assertions.assertContentContainsAny(result, Arrays.asList("May 5, 2023", "Mallori"));
    }

    @Test
    public void apiBatchBytesSync() throws Exception {
        JsonNode config = null;
        Path documentPath = E2EHelpers.resolveDocument("pdf/fake_memo.pdf");

        if (true && !Files.exists(documentPath)) {
            String msg = String.format("Skipping api_batch_bytes_sync: missing document at %s", documentPath);
            System.err.println(msg);
            org.junit.jupiter.api.Assumptions.assumeTrue(false, msg);
            return;
        }

        byte[] documentBytes = Files.readAllBytes(documentPath);
        String mimeType = Kreuzberg.detectMimeType(documentBytes);
        ExtractionConfig extractionConfig = E2EHelpers.buildConfig(config);
        List<BytesWithMime> items = Arrays.asList(new BytesWithMime(documentBytes, mimeType));
        List<ExtractionResult> results;
        try {
            results = Kreuzberg.batchExtractBytes(items, extractionConfig);
        } catch (Exception e) {
            String skipReason = E2EHelpers.skipReasonFor(e, "api_batch_bytes_sync", Collections.emptyList(), null);
            if (skipReason != null) {
                org.junit.jupiter.api.Assumptions.assumeTrue(false, skipReason);
                return;
            }
            throw e;
        }

        assertTrue(results.size() == 1, "Expected exactly 1 result from batch extraction");
        ExtractionResult result = results.get(0);

        E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
        E2EHelpers.Assertions.assertMinContentLength(result, 10);
        E2EHelpers.Assertions.assertContentContainsAny(result, Arrays.asList("May 5, 2023", "Mallori"));
    }

    @Test
    public void apiBatchFileAsync() throws Exception {
        JsonNode config = null;
        Path documentPath = E2EHelpers.resolveDocument("pdf/fake_memo.pdf");

        if (true && !Files.exists(documentPath)) {
            String msg = String.format("Skipping api_batch_file_async: missing document at %s", documentPath);
            System.err.println(msg);
            org.junit.jupiter.api.Assumptions.assumeTrue(false, msg);
            return;
        }

        ExtractionConfig extractionConfig = E2EHelpers.buildConfig(config);
        List<String> paths = Arrays.asList(documentPath.toString());
        java.util.concurrent.CompletableFuture<List<ExtractionResult>> future = Kreuzberg.batchExtractFilesAsync(paths, extractionConfig);
        List<ExtractionResult> results;
        try {
            results = future.get();
        } catch (java.util.concurrent.ExecutionException e) {
            Throwable cause = e.getCause() != null ? e.getCause() : e;
            if (cause instanceof Exception) {
                String skipReason = E2EHelpers.skipReasonFor((Exception) cause, "api_batch_file_async", Collections.emptyList(), null);
                if (skipReason != null) {
                    org.junit.jupiter.api.Assumptions.assumeTrue(false, skipReason);
                    return;
                }
            }
            throw e;
        }

        assertTrue(results.size() == 1, "Expected exactly 1 result from batch extraction");
        ExtractionResult result = results.get(0);

        E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
        E2EHelpers.Assertions.assertMinContentLength(result, 10);
        E2EHelpers.Assertions.assertContentContainsAny(result, Arrays.asList("May 5, 2023", "Mallori"));
    }

    @Test
    public void apiBatchFileSync() throws Exception {
        JsonNode config = null;
        Path documentPath = E2EHelpers.resolveDocument("pdf/fake_memo.pdf");

        if (true && !Files.exists(documentPath)) {
            String msg = String.format("Skipping api_batch_file_sync: missing document at %s", documentPath);
            System.err.println(msg);
            org.junit.jupiter.api.Assumptions.assumeTrue(false, msg);
            return;
        }

        ExtractionConfig extractionConfig = E2EHelpers.buildConfig(config);
        List<String> paths = Arrays.asList(documentPath.toString());
        List<ExtractionResult> results;
        try {
            results = Kreuzberg.batchExtractFiles(paths, extractionConfig);
        } catch (Exception e) {
            String skipReason = E2EHelpers.skipReasonFor(e, "api_batch_file_sync", Collections.emptyList(), null);
            if (skipReason != null) {
                org.junit.jupiter.api.Assumptions.assumeTrue(false, skipReason);
                return;
            }
            throw e;
        }

        assertTrue(results.size() == 1, "Expected exactly 1 result from batch extraction");
        ExtractionResult result = results.get(0);

        E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
        E2EHelpers.Assertions.assertMinContentLength(result, 10);
        E2EHelpers.Assertions.assertContentContainsAny(result, Arrays.asList("May 5, 2023", "Mallori"));
    }

    @Test
    public void apiExtractBytesAsync() throws Exception {
        JsonNode config = null;
        Path documentPath = E2EHelpers.resolveDocument("pdf/fake_memo.pdf");

        if (true && !Files.exists(documentPath)) {
            String msg = String.format("Skipping api_extract_bytes_async: missing document at %s", documentPath);
            System.err.println(msg);
            org.junit.jupiter.api.Assumptions.assumeTrue(false, msg);
            return;
        }

        byte[] documentBytes = Files.readAllBytes(documentPath);
        String mimeType = Kreuzberg.detectMimeType(documentBytes);
        ExtractionConfig extractionConfig = E2EHelpers.buildConfig(config);
        java.util.concurrent.CompletableFuture<ExtractionResult> future = Kreuzberg.extractBytesAsync(documentBytes, mimeType, extractionConfig);
        ExtractionResult result;
        try {
            result = future.get();
        } catch (java.util.concurrent.ExecutionException e) {
            Throwable cause = e.getCause() != null ? e.getCause() : e;
            if (cause instanceof Exception) {
                String skipReason = E2EHelpers.skipReasonFor((Exception) cause, "api_extract_bytes_async", Collections.emptyList(), null);
                if (skipReason != null) {
                    org.junit.jupiter.api.Assumptions.assumeTrue(false, skipReason);
                    return;
                }
            }
            throw e;
        }

        E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
        E2EHelpers.Assertions.assertMinContentLength(result, 10);
        E2EHelpers.Assertions.assertContentContainsAny(result, Arrays.asList("May 5, 2023", "Mallori"));
    }

    @Test
    public void apiExtractBytesSync() throws Exception {
        JsonNode config = null;
        Path documentPath = E2EHelpers.resolveDocument("pdf/fake_memo.pdf");

        if (true && !Files.exists(documentPath)) {
            String msg = String.format("Skipping api_extract_bytes_sync: missing document at %s", documentPath);
            System.err.println(msg);
            org.junit.jupiter.api.Assumptions.assumeTrue(false, msg);
            return;
        }

        byte[] documentBytes = Files.readAllBytes(documentPath);
        String mimeType = Kreuzberg.detectMimeType(documentBytes);
        ExtractionConfig extractionConfig = E2EHelpers.buildConfig(config);
        ExtractionResult result;
        try {
            result = Kreuzberg.extractBytes(documentBytes, mimeType, extractionConfig);
        } catch (Exception e) {
            String skipReason = E2EHelpers.skipReasonFor(e, "api_extract_bytes_sync", Collections.emptyList(), null);
            if (skipReason != null) {
                org.junit.jupiter.api.Assumptions.assumeTrue(false, skipReason);
                return;
            }
            throw e;
        }

        E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
        E2EHelpers.Assertions.assertMinContentLength(result, 10);
        E2EHelpers.Assertions.assertContentContainsAny(result, Arrays.asList("May 5, 2023", "Mallori"));
    }

    @Test
    public void apiExtractFileAsync() throws Exception {
        JsonNode config = null;
        Path documentPath = E2EHelpers.resolveDocument("pdf/fake_memo.pdf");

        if (true && !Files.exists(documentPath)) {
            String msg = String.format("Skipping api_extract_file_async: missing document at %s", documentPath);
            System.err.println(msg);
            org.junit.jupiter.api.Assumptions.assumeTrue(false, msg);
            return;
        }

        ExtractionConfig extractionConfig = E2EHelpers.buildConfig(config);
        java.util.concurrent.CompletableFuture<ExtractionResult> future = Kreuzberg.extractFileAsync(documentPath, extractionConfig);
        ExtractionResult result;
        try {
            result = future.get();
        } catch (java.util.concurrent.ExecutionException e) {
            Throwable cause = e.getCause() != null ? e.getCause() : e;
            if (cause instanceof Exception) {
                String skipReason = E2EHelpers.skipReasonFor((Exception) cause, "api_extract_file_async", Collections.emptyList(), null);
                if (skipReason != null) {
                    org.junit.jupiter.api.Assumptions.assumeTrue(false, skipReason);
                    return;
                }
            }
            throw e;
        }

        E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
        E2EHelpers.Assertions.assertMinContentLength(result, 10);
        E2EHelpers.Assertions.assertContentContainsAny(result, Arrays.asList("May 5, 2023", "Mallori"));
    }

    @Test
    public void apiExtractFileSync() throws Exception {
        JsonNode config = null;
        E2EHelpers.runFixture(
            "api_extract_file_sync",
            "pdf/fake_memo.pdf",
            config,
            Collections.emptyList(),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
                E2EHelpers.Assertions.assertMinContentLength(result, 10);
                E2EHelpers.Assertions.assertContentContainsAny(result, Arrays.asList("May 5, 2023", "Mallori"));
            }
        );
    }

    @Test
    public void configChunking() throws Exception {
        JsonNode config = MAPPER.readTree("{\"chunking\":{\"max_chars\":500,\"max_overlap\":50}}");
        E2EHelpers.runFixture(
            "config_chunking",
            "pdf/fake_memo.pdf",
            config,
            Collections.emptyList(),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
                E2EHelpers.Assertions.assertMinContentLength(result, 10);
                E2EHelpers.Assertions.assertChunks(result, 1, null, true, null);
            }
        );
    }

    @Test
    public void configDocumentStructure() throws Exception {
        JsonNode config = MAPPER.readTree("{\"include_document_structure\":true}");
        E2EHelpers.runFixture(
            "config_document_structure",
            "pdf/fake_memo.pdf",
            config,
            Collections.emptyList(),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
                E2EHelpers.Assertions.assertDocument(result, true, 1, Arrays.asList("paragraph"), null);
            }
        );
    }

    @Test
    public void configDocumentStructureDisabled() throws Exception {
        JsonNode config = null;
        E2EHelpers.runFixture(
            "config_document_structure_disabled",
            "pdf/fake_memo.pdf",
            config,
            Collections.emptyList(),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
                E2EHelpers.Assertions.assertDocument(result, false, null, null, null);
            }
        );
    }

    @Test
    public void configDocumentStructureWithHeadings() throws Exception {
        JsonNode config = MAPPER.readTree("{\"include_document_structure\":true}");
        E2EHelpers.runFixture(
            "config_document_structure_with_headings",
            "docx/fake.docx",
            config,
            Collections.emptyList(),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/vnd.openxmlformats-officedocument.wordprocessingml.document"));
                E2EHelpers.Assertions.assertDocument(result, true, 1, null, null);
            }
        );
    }

    @Test
    public void configForceOcr() throws Exception {
        JsonNode config = MAPPER.readTree("{\"force_ocr\":true}");
        E2EHelpers.runFixture(
            "config_force_ocr",
            "pdf/fake_memo.pdf",
            config,
            Arrays.asList("tesseract"),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
                E2EHelpers.Assertions.assertMinContentLength(result, 5);
            }
        );
    }

    @Test
    public void configHtmlOptions() throws Exception {
        JsonNode config = MAPPER.readTree("{\"html_options\":{\"include_links\":true}}");
        E2EHelpers.runFixture(
            "config_html_options",
            "html/complex_table.html",
            config,
            Collections.emptyList(),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("text/html"));
                E2EHelpers.Assertions.assertMinContentLength(result, 10);
                E2EHelpers.Assertions.assertContentNotEmpty(result);
            }
        );
    }

    @Test
    public void configImages() throws Exception {
        JsonNode config = MAPPER.readTree("{\"images\":{\"extract_images\":true}}");
        E2EHelpers.runFixture(
            "config_images",
            "pdf/embedded_images_tables.pdf",
            config,
            Collections.emptyList(),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
                E2EHelpers.Assertions.assertImages(result, 1, null, null);
            }
        );
    }

    @Test
    public void configKeywords() throws Exception {
        JsonNode config = MAPPER.readTree("{\"keywords\":{\"algorithm\":\"yake\",\"max_keywords\":10}}");
        E2EHelpers.runFixture(
            "config_keywords",
            "pdf/fake_memo.pdf",
            config,
            Arrays.asList("keywords-yake"),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
                E2EHelpers.Assertions.assertMinContentLength(result, 10);
                E2EHelpers.Assertions.assertMetadataExpectation(result, "keywords", Map.of("exists", true));
            }
        );
    }

    @Test
    public void configLanguageDetection() throws Exception {
        JsonNode config = MAPPER.readTree("{\"language_detection\":{\"enabled\":true}}");
        E2EHelpers.runFixture(
            "config_language_detection",
            "pdf/fake_memo.pdf",
            config,
            Collections.emptyList(),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
                E2EHelpers.Assertions.assertMinContentLength(result, 10);
                E2EHelpers.Assertions.assertDetectedLanguages(result, Arrays.asList("eng"), 0.50);
            }
        );
    }

    @Test
    public void configPages() throws Exception {
        JsonNode config = MAPPER.readTree("{\"pages\":{\"end\":3,\"start\":1}}");
        E2EHelpers.runFixture(
            "config_pages",
            "pdf/multi_page.pdf",
            config,
            Collections.emptyList(),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
                E2EHelpers.Assertions.assertMinContentLength(result, 10);
            }
        );
    }

    @Test
    public void configQualityDisabled() throws Exception {
        JsonNode config = MAPPER.readTree("{\"enable_quality_processing\":false}");
        E2EHelpers.runFixture(
            "config_quality_disabled",
            "pdf/fake_memo.pdf",
            config,
            Collections.emptyList(),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
                E2EHelpers.Assertions.assertMinContentLength(result, 10);
                E2EHelpers.Assertions.assertContentNotEmpty(result);
            }
        );
    }

    @Test
    public void configUseCacheFalse() throws Exception {
        JsonNode config = MAPPER.readTree("{\"use_cache\":false}");
        E2EHelpers.runFixture(
            "config_use_cache_false",
            "pdf/fake_memo.pdf",
            config,
            Collections.emptyList(),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
                E2EHelpers.Assertions.assertMinContentLength(result, 10);
            }
        );
    }

    @Test
    public void outputFormatBytesMarkdown() throws Exception {
        JsonNode config = MAPPER.readTree("{\"output_format\":\"markdown\"}");
        Path documentPath = E2EHelpers.resolveDocument("pdf/fake_memo.pdf");

        if (true && !Files.exists(documentPath)) {
            String msg = String.format("Skipping output_format_bytes_markdown: missing document at %s", documentPath);
            System.err.println(msg);
            org.junit.jupiter.api.Assumptions.assumeTrue(false, msg);
            return;
        }

        byte[] documentBytes = Files.readAllBytes(documentPath);
        String mimeType = Kreuzberg.detectMimeType(documentBytes);
        ExtractionConfig extractionConfig = E2EHelpers.buildConfig(config);
        ExtractionResult result;
        try {
            result = Kreuzberg.extractBytes(documentBytes, mimeType, extractionConfig);
        } catch (Exception e) {
            String skipReason = E2EHelpers.skipReasonFor(e, "output_format_bytes_markdown", Collections.emptyList(), null);
            if (skipReason != null) {
                org.junit.jupiter.api.Assumptions.assumeTrue(false, skipReason);
                return;
            }
            throw e;
        }

        E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
        E2EHelpers.Assertions.assertMinContentLength(result, 10);
    }

    @Test
    public void outputFormatDjot() throws Exception {
        JsonNode config = MAPPER.readTree("{\"output_format\":\"djot\"}");
        E2EHelpers.runFixture(
            "output_format_djot",
            "pdf/fake_memo.pdf",
            config,
            Collections.emptyList(),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
                E2EHelpers.Assertions.assertMinContentLength(result, 10);
            }
        );
    }

    @Test
    public void outputFormatHtml() throws Exception {
        JsonNode config = MAPPER.readTree("{\"output_format\":\"html\"}");
        E2EHelpers.runFixture(
            "output_format_html",
            "pdf/fake_memo.pdf",
            config,
            Collections.emptyList(),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
                E2EHelpers.Assertions.assertMinContentLength(result, 10);
            }
        );
    }

    @Test
    public void outputFormatMarkdown() throws Exception {
        JsonNode config = MAPPER.readTree("{\"output_format\":\"markdown\"}");
        E2EHelpers.runFixture(
            "output_format_markdown",
            "pdf/fake_memo.pdf",
            config,
            Collections.emptyList(),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
                E2EHelpers.Assertions.assertMinContentLength(result, 10);
            }
        );
    }

    @Test
    public void outputFormatPlain() throws Exception {
        JsonNode config = MAPPER.readTree("{\"output_format\":\"plain\"}");
        E2EHelpers.runFixture(
            "output_format_plain",
            "pdf/fake_memo.pdf",
            config,
            Collections.emptyList(),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
                E2EHelpers.Assertions.assertMinContentLength(result, 10);
            }
        );
    }

    @Test
    public void resultFormatElementBased() throws Exception {
        JsonNode config = MAPPER.readTree("{\"result_format\":\"element_based\"}");
        E2EHelpers.runFixture(
            "result_format_element_based",
            "pdf/fake_memo.pdf",
            config,
            Collections.emptyList(),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
                E2EHelpers.Assertions.assertElements(result, 1, null);
            }
        );
    }

    @Test
    public void resultFormatUnified() throws Exception {
        JsonNode config = MAPPER.readTree("{\"result_format\":\"unified\"}");
        E2EHelpers.runFixture(
            "result_format_unified",
            "pdf/fake_memo.pdf",
            config,
            Collections.emptyList(),
            null,
            true,
            result -> {
                E2EHelpers.Assertions.assertExpectedMime(result, Arrays.asList("application/pdf"));
                E2EHelpers.Assertions.assertMinContentLength(result, 10);
            }
        );
    }

}
