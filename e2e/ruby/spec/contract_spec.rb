# frozen_string_literal: true

# Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
# To regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang ruby
#
# Tests for contract fixtures.

# rubocop:disable Metrics/BlockLength
require_relative 'spec_helper'

RSpec.describe 'contract fixtures' do
  it 'api_batch_bytes_async' do
    E2ERuby.run_fixture_with_method(
      'api_batch_bytes_async',
      'pdf/fake_memo.pdf',
      nil,
      :batch_async,
      :bytes,
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_content_contains_any(result, ['May 5, 2023', 'Mallori'])
    end
  end

  it 'api_batch_bytes_sync' do
    E2ERuby.run_fixture_with_method(
      'api_batch_bytes_sync',
      'pdf/fake_memo.pdf',
      nil,
      :batch_sync,
      :bytes,
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_content_contains_any(result, ['May 5, 2023', 'Mallori'])
    end
  end

  it 'api_batch_file_async' do
    E2ERuby.run_fixture_with_method(
      'api_batch_file_async',
      'pdf/fake_memo.pdf',
      nil,
      :batch_async,
      :file,
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_content_contains_any(result, ['May 5, 2023', 'Mallori'])
    end
  end

  it 'api_batch_file_sync' do
    E2ERuby.run_fixture_with_method(
      'api_batch_file_sync',
      'pdf/fake_memo.pdf',
      nil,
      :batch_sync,
      :file,
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_content_contains_any(result, ['May 5, 2023', 'Mallori'])
    end
  end

  it 'api_extract_bytes_async' do
    E2ERuby.run_fixture_with_method(
      'api_extract_bytes_async',
      'pdf/fake_memo.pdf',
      nil,
      :async,
      :bytes,
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_content_contains_any(result, ['May 5, 2023', 'Mallori'])
    end
  end

  it 'api_extract_bytes_sync' do
    E2ERuby.run_fixture_with_method(
      'api_extract_bytes_sync',
      'pdf/fake_memo.pdf',
      nil,
      :sync,
      :bytes,
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_content_contains_any(result, ['May 5, 2023', 'Mallori'])
    end
  end

  it 'api_extract_file_async' do
    E2ERuby.run_fixture_with_method(
      'api_extract_file_async',
      'pdf/fake_memo.pdf',
      nil,
      :async,
      :file,
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_content_contains_any(result, ['May 5, 2023', 'Mallori'])
    end
  end

  it 'api_extract_file_sync' do
    E2ERuby.run_fixture(
      'api_extract_file_sync',
      'pdf/fake_memo.pdf',
      nil,
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_content_contains_any(result, ['May 5, 2023', 'Mallori'])
    end
  end

  it 'config_chunking' do
    E2ERuby.run_fixture(
      'config_chunking',
      'pdf/fake_memo.pdf',
      { chunking: { max_chars: 500, max_overlap: 50 } },
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_chunks(result, min_count: 1, each_has_content: true)
    end
  end

  it 'config_chunking_markdown' do
    E2ERuby.skip_if_feature_unavailable('chunking')
    E2ERuby.run_fixture(
      'config_chunking_markdown',
      'pdf/fake_memo.pdf',
      { chunking: { chunker_type: 'markdown', max_chars: 500, max_overlap: 50 } },
      requirements: %w[chunking],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_chunks(result, min_count: 1, each_has_content: true)
    end
  end

  it 'config_chunking_small' do
    E2ERuby.skip_if_feature_unavailable('chunking')
    E2ERuby.run_fixture(
      'config_chunking_small',
      'pdf/fake_memo.pdf',
      { chunking: { max_chars: 100, max_overlap: 20 } },
      requirements: %w[chunking],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_chunks(result, min_count: 2, each_has_content: true)
    end
  end

  it 'config_djot_content' do
    E2ERuby.skip_if_feature_unavailable('pdf')
    E2ERuby.run_fixture(
      'config_djot_content',
      'pdf/fake_memo.pdf',
      { output_format: 'djot' },
      requirements: %w[pdf],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_djot_content(result, has_content: true)
    end
  end

  it 'config_document_structure' do
    E2ERuby.run_fixture(
      'config_document_structure',
      'pdf/fake_memo.pdf',
      { include_document_structure: true },
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_document(result, has_document: true, min_node_count: 1,
                                                  node_types_include: %w[paragraph])
    end
  end

  it 'config_document_structure_disabled' do
    E2ERuby.run_fixture(
      'config_document_structure_disabled',
      'pdf/fake_memo.pdf',
      nil,
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_document(result, has_document: false)
    end
  end

  it 'config_document_structure_headings' do
    E2ERuby.skip_if_feature_unavailable('office')
    E2ERuby.run_fixture(
      'config_document_structure_headings',
      'office/docx/headers.docx',
      { include_document_structure: true },
      requirements: %w[office],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/vnd.openxmlformats-officedocument.wordprocessingml.document']
      )
      E2ERuby::Assertions.assert_document(result, has_document: true, min_node_count: 1,
                                                  node_types_include: %w[heading paragraph])
    end
  end

  it 'config_document_structure_with_headings' do
    E2ERuby.run_fixture(
      'config_document_structure_with_headings',
      'docx/fake.docx',
      { include_document_structure: true },
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/vnd.openxmlformats-officedocument.wordprocessingml.document']
      )
      E2ERuby::Assertions.assert_document(result, has_document: true, min_node_count: 1)
    end
  end

  it 'config_element_types' do
    E2ERuby.skip_if_feature_unavailable('office')
    E2ERuby.run_fixture(
      'config_element_types',
      'office/docx/headers.docx',
      { result_format: 'element_based' },
      requirements: %w[office],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/vnd.openxmlformats-officedocument.wordprocessingml.document']
      )
      E2ERuby::Assertions.assert_elements(result, min_count: 1, types_include: %w[title narrative_text])
    end
  end

  it 'config_force_ocr' do
    E2ERuby.skip_if_feature_unavailable('tesseract')
    E2ERuby.run_fixture(
      'config_force_ocr',
      'pdf/fake_memo.pdf',
      { force_ocr: true },
      requirements: %w[tesseract],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 5)
    end
  end

  it 'config_html_options' do
    E2ERuby.run_fixture(
      'config_html_options',
      'html/complex_table.html',
      { html_options: { include_links: true } },
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['text/html']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_content_not_empty(result)
    end
  end

  it 'config_images' do
    E2ERuby.run_fixture(
      'config_images',
      'pdf/embedded_images_tables.pdf',
      { images: { extract_images: true } },
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_images(result, min_count: 1)
    end
  end

  it 'config_keywords' do
    E2ERuby.skip_if_feature_unavailable('keywords-yake')
    E2ERuby.run_fixture(
      'config_keywords',
      'pdf/fake_memo.pdf',
      { keywords: { algorithm: 'yake', max_keywords: 10 } },
      requirements: %w[keywords-yake],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_keywords(result, has_keywords: true, min_count: 1)
    end
  end

  it 'config_language_detection' do
    E2ERuby.run_fixture(
      'config_language_detection',
      'pdf/fake_memo.pdf',
      { language_detection: { enabled: true } },
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_detected_languages(result, %w[eng], 0.5)
    end
  end

  it 'config_language_multi' do
    E2ERuby.skip_if_feature_unavailable('language-detection')
    E2ERuby.run_fixture(
      'config_language_multi',
      'pdf/fake_memo.pdf',
      { language_detection: { detect_multiple: true, enabled: true } },
      requirements: %w[language-detection],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_detected_languages(result, %w[eng], nil)
    end
  end

  it 'config_pages' do
    E2ERuby.skip_if_feature_unavailable('pdf')
    E2ERuby.run_fixture(
      'config_pages',
      'pdf/fake_memo.pdf',
      { pages: { extract_pages: true, insert_page_markers: true } },
      requirements: %w[pdf],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_content_contains_any(result, %w[PAGE])
    end
  end

  it 'config_pages_extract' do
    E2ERuby.skip_if_feature_unavailable('pdf')
    E2ERuby.run_fixture(
      'config_pages_extract',
      'pdf/fake_memo.pdf',
      { pages: { extract_pages: true } },
      requirements: %w[pdf],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_pages(result, min_count: 1)
    end
  end

  it 'config_pages_markers' do
    E2ERuby.skip_if_feature_unavailable('pdf')
    E2ERuby.run_fixture(
      'config_pages_markers',
      'pdf/fake_memo.pdf',
      { pages: { insert_page_markers: true } },
      requirements: %w[pdf],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_content_contains_any(result, %w[PAGE])
    end
  end

  it 'config_pdf_hierarchy' do
    E2ERuby.skip_if_feature_unavailable('pdf')
    E2ERuby.run_fixture(
      'config_pdf_hierarchy',
      'pdf/fake_memo.pdf',
      { pages: { extract_pages: true }, pdf_options: { hierarchy: { enabled: true, include_bbox: true } } },
      requirements: %w[pdf],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 50)
    end
  end

  it 'config_postprocessor' do
    E2ERuby.run_fixture(
      'config_postprocessor',
      'pdf/fake_memo.pdf',
      { postprocessor: { enabled: true } },
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_content_not_empty(result)
    end
  end

  it 'config_quality_disabled' do
    E2ERuby.run_fixture(
      'config_quality_disabled',
      'pdf/fake_memo.pdf',
      { enable_quality_processing: false },
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_content_not_empty(result)
    end
  end

  it 'config_quality_enabled' do
    E2ERuby.skip_if_feature_unavailable('quality')
    E2ERuby.run_fixture(
      'config_quality_enabled',
      'pdf/fake_memo.pdf',
      { enable_quality_processing: true },
      requirements: %w[quality],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
      E2ERuby::Assertions.assert_quality_score(result, has_score: true, min_score: 0, max_score: 1)
    end
  end

  it 'config_structured_output' do
    E2ERuby.skip_if_feature_unavailable('pdf')
    E2ERuby.run_fixture(
      'config_structured_output',
      'pdf/fake_memo.pdf',
      { output_format: 'structured' },
      requirements: %w[pdf],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
    end
  end

  it 'config_use_cache_false' do
    E2ERuby.run_fixture(
      'config_use_cache_false',
      'pdf/fake_memo.pdf',
      { use_cache: false },
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
    end
  end

  it 'output_format_bytes_markdown' do
    E2ERuby.run_fixture_with_method(
      'output_format_bytes_markdown',
      'pdf/fake_memo.pdf',
      { output_format: 'markdown' },
      :sync,
      :bytes,
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
    end
  end

  it 'output_format_djot' do
    E2ERuby.run_fixture(
      'output_format_djot',
      'pdf/fake_memo.pdf',
      { output_format: 'djot' },
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
    end
  end

  it 'output_format_html' do
    E2ERuby.run_fixture(
      'output_format_html',
      'pdf/fake_memo.pdf',
      { output_format: 'html' },
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
    end
  end

  it 'output_format_markdown' do
    E2ERuby.run_fixture(
      'output_format_markdown',
      'pdf/fake_memo.pdf',
      { output_format: 'markdown' },
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
    end
  end

  it 'output_format_plain' do
    E2ERuby.run_fixture(
      'output_format_plain',
      'pdf/fake_memo.pdf',
      { output_format: 'plain' },
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
    end
  end

  it 'result_format_element_based' do
    E2ERuby.run_fixture(
      'result_format_element_based',
      'pdf/fake_memo.pdf',
      { result_format: 'element_based' },
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_elements(result, min_count: 1)
    end
  end

  it 'result_format_unified' do
    E2ERuby.run_fixture(
      'result_format_unified',
      'pdf/fake_memo.pdf',
      { result_format: 'unified' },
      requirements: [],
      notes: nil,
      skip_if_missing: true
    ) do |result|
      E2ERuby::Assertions.assert_expected_mime(
        result,
        ['application/pdf']
      )
      E2ERuby::Assertions.assert_min_content_length(result, 10)
    end
  end
end
# rubocop:enable, Metrics/BlockLength
