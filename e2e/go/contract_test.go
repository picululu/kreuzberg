// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
// Category: contract

package e2e

import "testing"

func TestContractApiBatchBytesAsync(t *testing.T) {
	results := runBatchExtractionAsync(t, []string{"pdf/fake_memo.pdf"}, nil)
	if len(results) == 0 {
		t.Fatal("expected at least one result from batch extraction")
	}
	result := results[0]
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertContentContainsAny(t, result, []string{"May 5, 2023", "Mallori"})
}

func TestContractApiBatchBytesSync(t *testing.T) {
	results := runBatchExtraction(t, []string{"pdf/fake_memo.pdf"}, nil)
	if len(results) == 0 {
		t.Fatal("expected at least one result from batch extraction")
	}
	result := results[0]
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertContentContainsAny(t, result, []string{"May 5, 2023", "Mallori"})
}

func TestContractApiBatchFileAsync(t *testing.T) {
	results := runBatchExtractionAsync(t, []string{"pdf/fake_memo.pdf"}, nil)
	if len(results) == 0 {
		t.Fatal("expected at least one result from batch extraction")
	}
	result := results[0]
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertContentContainsAny(t, result, []string{"May 5, 2023", "Mallori"})
}

func TestContractApiBatchFileSync(t *testing.T) {
	results := runBatchExtraction(t, []string{"pdf/fake_memo.pdf"}, nil)
	if len(results) == 0 {
		t.Fatal("expected at least one result from batch extraction")
	}
	result := results[0]
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertContentContainsAny(t, result, []string{"May 5, 2023", "Mallori"})
}

func TestContractApiExtractBytesAsync(t *testing.T) {
	result := runExtractionBytesAsync(t, "pdf/fake_memo.pdf", nil)
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertContentContainsAny(t, result, []string{"May 5, 2023", "Mallori"})
}

func TestContractApiExtractBytesSync(t *testing.T) {
	result := runExtractionBytes(t, "pdf/fake_memo.pdf", nil)
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertContentContainsAny(t, result, []string{"May 5, 2023", "Mallori"})
}

func TestContractApiExtractFileAsync(t *testing.T) {
	result := runExtractionAsync(t, "pdf/fake_memo.pdf", nil)
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertContentContainsAny(t, result, []string{"May 5, 2023", "Mallori"})
}

func TestContractApiExtractFileSync(t *testing.T) {
	result := runExtraction(t, "pdf/fake_memo.pdf", nil)
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertContentContainsAny(t, result, []string{"May 5, 2023", "Mallori"})
}

func TestContractConfigChunking(t *testing.T) {
	result := runExtraction(t, "pdf/fake_memo.pdf", []byte(`{
"chunking": {
	"max_chars": 500,
	"max_overlap": 50
}
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertChunks(t, result, intPtr(1), nil, boolPtr(true), nil)
}

func TestContractConfigDocumentStructure(t *testing.T) {
	result := runExtraction(t, "pdf/fake_memo.pdf", []byte(`{
"include_document_structure": true
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertDocument(t, result, true, intPtr(1), []string{"paragraph"}, nil)
}

func TestContractConfigDocumentStructureDisabled(t *testing.T) {
	result := runExtraction(t, "pdf/fake_memo.pdf", nil)
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertDocument(t, result, false, nil, nil, nil)
}

func TestContractConfigDocumentStructureWithHeadings(t *testing.T) {
	result := runExtraction(t, "docx/fake.docx", []byte(`{
"include_document_structure": true
}`))
	assertExpectedMime(t, result, []string{"application/vnd.openxmlformats-officedocument.wordprocessingml.document"})
	assertDocument(t, result, true, intPtr(1), nil, nil)
}

func TestContractConfigForceOcr(t *testing.T) {
	skipIfFeatureUnavailable(t, "tesseract")
	result := runExtraction(t, "pdf/fake_memo.pdf", []byte(`{
"force_ocr": true
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 5)
}

func TestContractConfigHtmlOptions(t *testing.T) {
	result := runExtraction(t, "html/complex_table.html", []byte(`{
"html_options": {
	"include_links": true
}
}`))
	assertExpectedMime(t, result, []string{"text/html"})
	assertMinContentLength(t, result, 10)
	assertContentNotEmpty(t, result)
}

func TestContractConfigImages(t *testing.T) {
	result := runExtraction(t, "pdf/embedded_images_tables.pdf", []byte(`{
"images": {
	"extract_images": true
}
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertImages(t, result, intPtr(1), nil, nil)
}

func TestContractConfigKeywords(t *testing.T) {
	skipIfFeatureUnavailable(t, "keywords-yake")
	result := runExtraction(t, "pdf/fake_memo.pdf", []byte(`{
"keywords": {
	"algorithm": "yake",
	"max_keywords": 10
}
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertKeywords(t, result, boolPtr(true), intPtr(1), nil)
}

func TestContractConfigLanguageDetection(t *testing.T) {
	result := runExtraction(t, "pdf/fake_memo.pdf", []byte(`{
"language_detection": {
	"enabled": true
}
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertDetectedLanguages(t, result, []string{"eng"}, floatPtr(0.5))
}

func TestContractConfigPages(t *testing.T) {
	result := runExtraction(t, "pdf/multi_page.pdf", []byte(`{
"pages": {
	"end": 3,
	"start": 1
}
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
}

func TestContractConfigQualityDisabled(t *testing.T) {
	result := runExtraction(t, "pdf/fake_memo.pdf", []byte(`{
"enable_quality_processing": false
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertContentNotEmpty(t, result)
}

func TestContractConfigUseCacheFalse(t *testing.T) {
	result := runExtraction(t, "pdf/fake_memo.pdf", []byte(`{
"use_cache": false
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
}

func TestContractOutputFormatBytesMarkdown(t *testing.T) {
	result := runExtractionBytes(t, "pdf/fake_memo.pdf", []byte(`{
"output_format": "markdown"
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
}

func TestContractOutputFormatDjot(t *testing.T) {
	result := runExtraction(t, "pdf/fake_memo.pdf", []byte(`{
"output_format": "djot"
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
}

func TestContractOutputFormatHtml(t *testing.T) {
	result := runExtraction(t, "pdf/fake_memo.pdf", []byte(`{
"output_format": "html"
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
}

func TestContractOutputFormatMarkdown(t *testing.T) {
	result := runExtraction(t, "pdf/fake_memo.pdf", []byte(`{
"output_format": "markdown"
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
}

func TestContractOutputFormatPlain(t *testing.T) {
	result := runExtraction(t, "pdf/fake_memo.pdf", []byte(`{
"output_format": "plain"
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
}

func TestContractResultFormatElementBased(t *testing.T) {
	result := runExtraction(t, "pdf/fake_memo.pdf", []byte(`{
"result_format": "element_based"
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertElements(t, result, intPtr(1), nil)
}

func TestContractResultFormatUnified(t *testing.T) {
	result := runExtraction(t, "pdf/fake_memo.pdf", []byte(`{
"result_format": "unified"
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
}
