# Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
# To regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang python

from __future__ import annotations

from collections.abc import Mapping
from pathlib import Path
from typing import Any

import pytest

from kreuzberg import (
    ChunkingConfig,
    EmbeddingConfig,
    EmbeddingModelType,
    ExtractionConfig,
    HierarchyConfig,
    ImageExtractionConfig,
    KeywordAlgorithm,
    KeywordConfig,
    LanguageDetectionConfig,
    OcrConfig,
    OutputFormat,
    PageConfig,
    PdfConfig,
    PostProcessorConfig,
    ResultFormat,
    TokenReductionConfig,
)

_WORKSPACE_ROOT = Path(__file__).resolve().parent.parent.parent.parent
_TEST_DOCUMENTS = _WORKSPACE_ROOT / "test_documents"


def resolve_document(relative: str) -> Path:
    """Return absolute path to a document in test_documents."""

    return _TEST_DOCUMENTS / relative


def _build_chunking(chunking_data: dict[str, Any]) -> ChunkingConfig:
    """Convert a chunking dict with nested embedding to ChunkingConfig."""
    cd = dict(chunking_data)
    if "embedding" in cd and isinstance(cd["embedding"], dict):
        emb = dict(cd["embedding"])
        model = None
        if "model" in emb and isinstance(emb["model"], dict):
            m = emb["model"]
            if m.get("type") == "preset":
                model = EmbeddingModelType.preset(m.get("name", "balanced"))
            del emb["model"]
        if model is not None:
            emb["model"] = model
        cd["embedding"] = EmbeddingConfig(**emb)
    return ChunkingConfig(**cd)


def _build_keywords(keywords_data: dict[str, Any]) -> KeywordConfig:
    """Convert a keywords dict to KeywordConfig."""
    kw = dict(keywords_data)
    if "algorithm" in kw:
        algo_map = {"yake": KeywordAlgorithm.Yake, "rake": KeywordAlgorithm.Rake}
        kw["algorithm"] = algo_map.get(kw["algorithm"], KeywordAlgorithm.Yake)
    return KeywordConfig(**kw)


def _build_pdf_options(pdf_data: dict[str, Any]) -> PdfConfig:
    """Convert a pdf_options dict with nested hierarchy to PdfConfig."""
    po = dict(pdf_data)
    if "hierarchy" in po and isinstance(po["hierarchy"], dict):
        po["hierarchy"] = HierarchyConfig(**po["hierarchy"])
    return PdfConfig(**po)


def _build_config_objects(config: dict[str, Any], kwargs: dict[str, Any]) -> None:
    """Build typed config objects from plain dicts into kwargs."""
    if (ocr_data := config.get("ocr")) is not None:
        kwargs["ocr"] = OcrConfig(**ocr_data)
    if (chunking_data := config.get("chunking")) is not None:
        kwargs["chunking"] = _build_chunking(chunking_data)
    if (images_data := config.get("images")) is not None:
        kwargs["images"] = ImageExtractionConfig(**images_data)
    if (pdf_options := config.get("pdf_options")) is not None:
        kwargs["pdf_options"] = _build_pdf_options(pdf_options)
    if (token_reduction := config.get("token_reduction")) is not None:
        kwargs["token_reduction"] = TokenReductionConfig(**token_reduction)
    if (language_detection := config.get("language_detection")) is not None:
        kwargs["language_detection"] = LanguageDetectionConfig(**language_detection)
    if (keywords_data := config.get("keywords")) is not None:
        kwargs["keywords"] = _build_keywords(keywords_data)
    if (postprocessor := config.get("postprocessor")) is not None:
        kwargs["postprocessor"] = PostProcessorConfig(**postprocessor)
    if (pages_data := config.get("pages")) is not None:
        kwargs["pages"] = PageConfig(**pages_data)


def build_config(config: dict[str, Any] | None) -> ExtractionConfig:
    """Construct an ExtractionConfig from a plain dictionary."""

    if not config:
        return ExtractionConfig()

    kwargs: dict[str, Any] = {}

    for key in ("use_cache", "enable_quality_processing", "force_ocr", "include_document_structure"):
        if key in config:
            kwargs[key] = config[key]

    _build_config_objects(config, kwargs)

    if (output_format := config.get("output_format")) is not None:
        kwargs["output_format"] = OutputFormat(output_format)

    if (result_format := config.get("result_format")) is not None:
        kwargs["result_format"] = ResultFormat(result_format)

    return ExtractionConfig(**kwargs)


def assert_expected_mime(result: Any, expected: list[str]) -> None:
    if not expected:
        return
    if not any(token in result.mime_type for token in expected):
        pytest.fail(f"Expected MIME {result.mime_type!r} to match one of {expected!r}")


def assert_min_content_length(result: Any, minimum: int) -> None:
    if len(result.content) < minimum:
        pytest.fail(f"Expected content length >= {minimum}, got {len(result.content)}")


def assert_max_content_length(result: Any, maximum: int) -> None:
    if len(result.content) > maximum:
        pytest.fail(f"Expected content length <= {maximum}, got {len(result.content)}")


def assert_content_contains_any(result: Any, snippets: list[str]) -> None:
    if not snippets:
        return
    lowered = result.content.lower()
    preview = result.content[:160]
    if not any(snippet.lower() in lowered for snippet in snippets):
        pytest.fail(f"Expected content to contain any of {snippets!r}. Preview: {preview!r}")


def assert_content_contains_all(result: Any, snippets: list[str]) -> None:
    if not snippets:
        return
    lowered = result.content.lower()
    missing = [snippet for snippet in snippets if snippet.lower() not in lowered]
    if missing:
        pytest.fail(f"Expected content to contain all snippets {snippets!r}. Missing {missing!r}")


def assert_table_count(result: Any, minimum: int | None, maximum: int | None) -> None:
    count = len(getattr(result, "tables", []) or [])
    if minimum is not None and count < minimum:
        pytest.fail(f"Expected at least {minimum} tables, found {count}")
    if maximum is not None and count > maximum:
        pytest.fail(f"Expected at most {maximum} tables, found {count}")


def assert_detected_languages(result: Any, expected: list[str], min_confidence: float | None) -> None:
    if not expected:
        return
    languages = result.detected_languages
    if languages is None:
        pytest.fail("Expected detected languages but field is None")

    missing = [lang for lang in expected if lang not in languages]
    if missing:
        pytest.fail(f"Expected languages {expected!r}, missing {missing!r}")

    if min_confidence is not None:
        confidence = result.metadata.get("confidence") if isinstance(result.metadata, Mapping) else None
        if confidence is not None and confidence < min_confidence:
            pytest.fail(f"Expected confidence >= {min_confidence}, got {confidence}")


def assert_metadata_expectation(result: Any, path: str, expectation: dict[str, Any]) -> None:
    value = _lookup_path(result.metadata, path)
    if value is None:
        pytest.fail(f"Metadata path '{path}' missing in {result.metadata!r}")

    if "eq" in expectation and not _values_equal(value, expectation["eq"]):
        pytest.fail(f"Expected metadata '{path}' == {expectation['eq']!r}, got {value!r}")

    if "gte" in expectation:
        actual = float(value)
        if actual < float(expectation["gte"]):
            pytest.fail(f"Expected metadata '{path}' >= {expectation['gte']}, got {actual}")

    if "lte" in expectation:
        actual = float(value)
        if actual > float(expectation["lte"]):
            pytest.fail(f"Expected metadata '{path}' <= {expectation['lte']}, got {actual}")

    if "contains" in expectation:
        expected_values = expectation["contains"]
        if isinstance(value, str) and isinstance(expected_values, str):
            if expected_values not in value:
                pytest.fail(f"Expected metadata '{path}' string to contain {expected_values!r}")
        elif isinstance(value, (list, tuple, set)) and isinstance(expected_values, str):
            if expected_values not in value:
                pytest.fail(f"Expected metadata '{path}' to contain {expected_values!r}")
        elif isinstance(value, (list, tuple, set)):
            missing = [item for item in expected_values if item not in value]
            if missing:
                pytest.fail(f"Expected metadata '{path}' to contain {expected_values!r}, missing {missing!r}")
        else:
            pytest.fail(f"Unsupported contains expectation for metadata '{path}': {value!r}")

    if expectation.get("exists") is False:
        pytest.fail("exists=False not supported for metadata expectations")


def _lookup_path(metadata: Mapping[str, Any] | None, path: str) -> Any:
    if not isinstance(metadata, Mapping):
        return None

    def _lookup(source: Mapping[str, Any]) -> Any:
        current: Any = source
        for segment in path.split("."):
            if not isinstance(current, Mapping) or segment not in current:
                return None
            current = current[segment]
        return current

    direct = _lookup(metadata)
    if direct is not None:
        return direct

    format_metadata = metadata.get("format")
    if isinstance(format_metadata, Mapping):
        return _lookup(format_metadata)
    return None


def _values_equal(lhs: Any, rhs: Any) -> bool:
    if isinstance(lhs, str) and isinstance(rhs, str):
        return lhs == rhs
    if isinstance(lhs, (int, float)) and isinstance(rhs, (int, float)):
        return float(lhs) == float(rhs)
    if isinstance(lhs, bool) and isinstance(rhs, bool):
        return lhs is rhs
    return bool(lhs == rhs)


def assert_chunks(
    result: Any,
    min_count: int | None = None,
    max_count: int | None = None,
    each_has_content: bool | None = None,
    each_has_embedding: bool | None = None,
) -> None:
    chunks = getattr(result, "chunks", None)
    if chunks is None:
        pytest.fail("Expected chunks but got None")
    count = len(chunks)
    if min_count is not None and count < min_count:
        pytest.fail(f"Expected at least {min_count} chunks, found {count}")
    if max_count is not None and count > max_count:
        pytest.fail(f"Expected at most {max_count} chunks, found {count}")
    if each_has_content:
        for i, chunk in enumerate(chunks):
            if not getattr(chunk, "content", None):
                pytest.fail(f"Chunk {i} has no content")
    if each_has_embedding:
        for i, chunk in enumerate(chunks):
            if not getattr(chunk, "embedding", None):
                pytest.fail(f"Chunk {i} has no embedding")


def assert_images(
    result: Any,
    min_count: int | None = None,
    max_count: int | None = None,
    formats_include: list[str] | None = None,
) -> None:
    images = getattr(result, "images", None)
    if images is None:
        pytest.fail("Expected images but got None")
    count = len(images)
    if min_count is not None and count < min_count:
        pytest.fail(f"Expected at least {min_count} images, found {count}")
    if max_count is not None and count > max_count:
        pytest.fail(f"Expected at most {max_count} images, found {count}")
    if formats_include:
        found_formats = {getattr(img, "format", None) for img in images}
        for fmt in formats_include:
            if fmt not in found_formats:
                pytest.fail(f"Expected image format {fmt!r} not found in {found_formats}")


def assert_pages(
    result: Any,
    min_count: int | None = None,
    exact_count: int | None = None,
) -> None:
    pages = getattr(result, "pages", None)
    if pages is None:
        pytest.fail("Expected pages but got None")
    count = len(pages)
    if exact_count is not None and count != exact_count:
        pytest.fail(f"Expected exactly {exact_count} pages, found {count}")
    if min_count is not None and count < min_count:
        pytest.fail(f"Expected at least {min_count} pages, found {count}")
    for page in pages:
        is_blank = page.get("is_blank") if isinstance(page, dict) else getattr(page, "is_blank", None)
        assert is_blank is None or isinstance(is_blank, bool), f"is_blank should be None or bool, got {type(is_blank)}"


def assert_elements(
    result: Any,
    min_count: int | None = None,
    types_include: list[str] | None = None,
) -> None:
    elements = getattr(result, "elements", None)
    if elements is None:
        pytest.fail("Expected elements but got None")
    count = len(elements)
    if min_count is not None and count < min_count:
        pytest.fail(f"Expected at least {min_count} elements, found {count}")
    if types_include:
        found_types = {getattr(el, "type", None) for el in elements}
        for el_type in types_include:
            if el_type not in found_types:
                pytest.fail(f"Expected element type {el_type!r} not found in {found_types}")


def assert_output_format(result: Any, expected: str) -> None:
    actual = getattr(result, "output_format", None)
    if actual is None:
        pytest.fail("Expected output_format but field is None")
    actual_value = actual.value if hasattr(actual, "value") else str(actual)
    if actual_value.lower() != expected.lower():
        pytest.fail(f"Expected output_format {expected!r}, got {actual_value!r}")


def assert_result_format(result: Any, expected: str) -> None:
    actual = getattr(result, "result_format", None)
    if actual is None:
        pytest.fail("Expected result_format but field is None")
    actual_value = actual.value if hasattr(actual, "value") else str(actual)
    if actual_value.lower() != expected.lower():
        pytest.fail(f"Expected result_format {expected!r}, got {actual_value!r}")


def assert_ocr_elements(
    result: Any,
    has_elements: bool | None = None,
    elements_have_geometry: bool | None = None,
    elements_have_confidence: bool | None = None,
    min_count: int | None = None,
) -> None:
    ocr_elements = _get_field(result, "ocr_elements")
    if has_elements:
        if ocr_elements is None:
            pytest.fail("Expected ocr_elements but got None")
        if not isinstance(ocr_elements, (list, tuple)):
            pytest.fail(f"Expected ocr_elements to be a list, got {type(ocr_elements)}")
        if len(ocr_elements) == 0:
            pytest.fail("Expected ocr_elements to be non-empty")
    if isinstance(ocr_elements, (list, tuple)):
        if min_count is not None and len(ocr_elements) < min_count:
            pytest.fail(f"Expected at least {min_count} ocr_elements, found {len(ocr_elements)}")
        if elements_have_geometry:
            for i, el in enumerate(ocr_elements):
                geometry = _get_field(el, "geometry")
                if geometry is None:
                    pytest.fail(f"OCR element {i} has no geometry")
                geom_type = _get_field(geometry, "type")
                if geom_type not in ("rectangle", "quadrilateral"):
                    pytest.fail(f"OCR element {i} has invalid geometry type: {geom_type}")
        if elements_have_confidence:
            for i, el in enumerate(ocr_elements):
                confidence = _get_field(el, "confidence")
                if confidence is None:
                    pytest.fail(f"OCR element {i} has no confidence")
                recognition = _get_field(confidence, "recognition")
                if not isinstance(recognition, (int, float)) or recognition <= 0:
                    pytest.fail(f"OCR element {i} has invalid confidence recognition: {recognition}")


def _get_field(obj: Any, *keys: str) -> Any:
    """Get a field from an object, supporting both dict and attribute access."""
    for key in keys:
        val = obj.get(key) if isinstance(obj, dict) else getattr(obj, key, None)
        if val is not None:
            return val
    return None


def _get_document_nodes(document: Any) -> list[Any]:
    if isinstance(document, (list, tuple)):
        return list(document)
    nodes = _get_field(document, "nodes")
    if nodes is None:
        pytest.fail("Expected document.nodes but got None")
    return nodes


def _get_node_type(node: Any) -> str | None:
    content = _get_field(node, "content")
    if content is not None:
        return _get_field(content, "node_type", "type")
    return _get_field(node, "node_type", "type")


def _get_node_types(nodes: list[Any]) -> set[str]:
    found: set[str] = set()
    for node in nodes:
        node_type = _get_node_type(node)
        if node_type:
            found.add(node_type)
    return found


def _check_groups(nodes: list[Any], has_groups: bool) -> None:

    has_group_nodes = any(_get_node_type(n) == "group" for n in nodes)
    if has_groups and not has_group_nodes:
        pytest.fail("Expected document to have group nodes but found none")
    if not has_groups and has_group_nodes:
        pytest.fail("Expected document to not have group nodes but found some")


def assert_document(
    result: Any,
    has_document: bool = False,
    min_node_count: int | None = None,
    node_types_include: list[str] | None = None,
    has_groups: bool | None = None,
) -> None:
    document = getattr(result, "document", None)
    if not has_document:
        if document is not None:
            pytest.fail(f"Expected document to be None but got {type(document)}")
        return
    if document is None:
        pytest.fail("Expected document but got None")
    nodes = _get_document_nodes(document)
    if min_node_count is not None and len(nodes) < min_node_count:
        pytest.fail(f"Expected at least {min_node_count} nodes, found {len(nodes)}")
    if node_types_include:
        found_types = _get_node_types(nodes)
        for expected_type in node_types_include:
            if expected_type not in found_types:
                pytest.fail(f"Expected node type {expected_type!r} not found in {found_types}")
    if has_groups is not None:
        _check_groups(nodes, has_groups)


def assert_keywords(
    result: Any,
    has_keywords: bool | None = None,
    min_count: int | None = None,
    max_count: int | None = None,
) -> None:
    keywords = getattr(result, "extracted_keywords", None)
    if has_keywords is True:
        if keywords is None:
            pytest.fail("Expected keywords but got None")
        if not isinstance(keywords, (list, tuple)):
            pytest.fail(f"Expected keywords list, got {type(keywords)}")
        if len(keywords) == 0:
            pytest.fail("Expected non-empty keywords list")
    if has_keywords is False and keywords is not None and len(keywords) > 0:
        pytest.fail(f"Expected no keywords but found {len(keywords)}")
    if keywords is not None and isinstance(keywords, (list, tuple)):
        if min_count is not None and len(keywords) < min_count:
            pytest.fail(f"Expected >= {min_count} keywords, found {len(keywords)}")
        if max_count is not None and len(keywords) > max_count:
            pytest.fail(f"Expected <= {max_count} keywords, found {len(keywords)}")


def assert_content_not_empty(result: Any) -> None:
    content = getattr(result, "content", None)
    if content is None or len(content.strip()) == 0:
        pytest.fail("Expected non-empty content")


def assert_table_bounding_boxes(result: Any, expected: bool) -> None:
    if expected:
        tables = getattr(result, "tables", None) or []
        assert len(tables) > 0, "Expected tables with bounding boxes but no tables found"
        for table in tables:
            bb = getattr(table, "bounding_box", None) or (
                table.get("bounding_box") if isinstance(table, dict) else None
            )
            assert bb is not None, "Expected table to have bounding_box but it was None"


def assert_table_content_contains_any(result: Any, snippets: list[str]) -> None:
    tables = getattr(result, "tables", None) or []
    assert len(tables) > 0, "Expected tables but none found"
    all_cells = [
        str(cell).lower()
        for table in tables
        for row in (getattr(table, "cells", None) or (table.get("cells") if isinstance(table, dict) else []) or [])
        for cell in row
    ]
    found = any(s.lower() in cell for s in snippets for cell in all_cells)
    assert found, f"No table cell contains any of {snippets}"


def assert_image_bounding_boxes(result: Any, expected: bool) -> None:
    if expected:
        images = getattr(result, "images", None) or []
        assert len(images) > 0, "Expected images with bounding boxes but no images found"
        for img in images:
            bb = getattr(img, "bounding_box", None) or (img.get("bounding_box") if isinstance(img, dict) else None)
            assert bb is not None, "Expected image to have bounding_box but it was None"


def assert_quality_score(
    result: Any, has_score: bool | None = None, min_score: float | None = None, max_score: float | None = None
) -> None:
    score = getattr(result, "quality_score", None)
    if isinstance(result, dict):
        score = result.get("quality_score")
    if has_score is True:
        assert score is not None, "Expected quality_score to be present"
    if has_score is False:
        assert score is None, "Expected quality_score to be absent"
    if min_score is not None:
        assert score is not None, "quality_score must be present for min_score check"
        assert score >= min_score, f"quality_score {score} < {min_score}"
    if max_score is not None:
        assert score is not None, "quality_score must be present for max_score check"
        assert score <= max_score, f"quality_score {score} > {max_score}"


def assert_processing_warnings(result: Any, max_count: int | None = None, is_empty: bool | None = None) -> None:
    warnings = getattr(result, "processing_warnings", None) or []
    if isinstance(result, dict):
        warnings = result.get("processing_warnings", [])
    if max_count is not None:
        assert len(warnings) <= max_count, f"processing_warnings count {len(warnings)} > {max_count}"
    if is_empty is True:
        assert len(warnings) == 0, f"Expected empty processing_warnings, got {len(warnings)}"


def assert_djot_content(result: Any, has_content: bool | None = None, min_blocks: int | None = None) -> None:
    djot = getattr(result, "djot_content", None)
    if isinstance(result, dict):
        djot = result.get("djot_content")
    if has_content is True:
        assert djot is not None, "Expected djot_content to be present"
    if has_content is False:
        assert djot is None, "Expected djot_content to be absent"
    if min_blocks is not None:
        assert djot is not None, "djot_content required for min_blocks assertion"
        blocks = getattr(djot, "blocks", None) or (djot.get("blocks") if isinstance(djot, dict) else [])
        assert len(blocks or []) >= min_blocks, f"djot_content blocks {len(blocks or [])} < {min_blocks}"
