/* Auto-generated C bindings for Kreuzberg */

#ifndef KREUZBERG_FFI_H
#define KREUZBERG_FFI_H

#pragma once

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * C-compatible extraction result structure
 */
typedef struct CExtractionResult {
  /**
   * Extracted text content (null-terminated UTF-8 string, must be freed with kreuzberg_free_string)
   */
  char *content;
  /**
   * Detected MIME type (null-terminated string, must be freed with kreuzberg_free_string)
   */
  char *mime_type;
  /**
   * Document language (null-terminated string, or NULL if not available, must be freed with kreuzberg_free_string)
   */
  char *language;
  /**
   * Document date (null-terminated string, or NULL if not available, must be freed with kreuzberg_free_string)
   */
  char *date;
  /**
   * Document subject (null-terminated string, or NULL if not available, must be freed with kreuzberg_free_string)
   */
  char *subject;
  /**
   * Tables as JSON array (null-terminated string, or NULL if no tables, must be freed with kreuzberg_free_string)
   */
  char *tables_json;
  /**
   * Detected languages as JSON array (null-terminated string, or NULL if not available, must be freed with kreuzberg_free_string)
   */
  char *detected_languages_json;
  /**
   * Metadata as JSON object (null-terminated string, or NULL if no metadata, must be freed with kreuzberg_free_string)
   */
  char *metadata_json;
  /**
   * Text chunks as JSON array (null-terminated string, or NULL if not available, must be freed with kreuzberg_free_string)
   */
  char *chunks_json;
  /**
   * Extracted images as JSON array (null-terminated string, or NULL if not available, must be freed with kreuzberg_free_string)
   */
  char *images_json;
  /**
   * Whether extraction was successful
   */
  bool success;
} CExtractionResult;

/**
 * C-compatible structure for batch extraction results
 */
typedef struct CBatchResult {
  /**
   * Array of extraction results
   */
  struct CExtractionResult **results;
  /**
   * Number of results
   */
  uintptr_t count;
  /**
   * Whether batch operation was successful
   */
  bool success;
} CBatchResult;

/**
 * C-compatible structure for passing byte array with MIME type in batch operations
 */
typedef struct CBytesWithMime {
  /**
   * Pointer to byte data
   */
  const uint8_t *data;
  /**
   * Length of byte data
   */
  uintptr_t data_len;
  /**
   * MIME type as null-terminated C string
   */
  const char *mime_type;
} CBytesWithMime;

/**
 * Type alias for the OCR backend callback function.
 *
 * # Parameters
 *
 * - `image_bytes`: Pointer to image data
 * - `image_length`: Length of image data in bytes
 * - `config_json`: JSON-encoded OcrConfig (null-terminated string)
 *
 * # Returns
 *
 * Null-terminated string containing extracted text (must be freed by Rust via kreuzberg_free_string),
 * or NULL on error.
 *
 * # Safety
 *
 * The callback must:
 * - Not store the image_bytes pointer (it's only valid for the duration of the call)
 * - Return a valid null-terminated UTF-8 string allocated by the caller
 * - Return NULL on error (error message should be retrievable separately)
 */
typedef char *(*OcrBackendCallback)(const uint8_t *image_bytes,
                                    uintptr_t image_length,
                                    const char *config_json);

/**
 * Type alias for the PostProcessor callback function.
 *
 * # Parameters
 *
 * - `result_json`: JSON-encoded ExtractionResult (null-terminated string)
 *
 * # Returns
 *
 * Null-terminated JSON string containing the processed ExtractionResult
 * (must be freed by Rust via kreuzberg_free_string), or NULL on error.
 *
 * # Safety
 *
 * The callback must:
 * - Not store the result_json pointer (it's only valid for the duration of the call)
 * - Return a valid null-terminated UTF-8 JSON string allocated by the caller
 * - Return NULL on error (error message should be retrievable separately)
 */
typedef char *(*PostProcessorCallback)(const char *result_json);

/**
 * Type alias for the Validator callback function.
 *
 * # Parameters
 *
 * - `result_json`: JSON-encoded ExtractionResult (null-terminated string)
 *
 * # Returns
 *
 * Null-terminated error message string if validation fails (must be freed by Rust
 * via kreuzberg_free_string), or NULL if validation passes.
 *
 * # Safety
 *
 * The callback must:
 * - Not store the result_json pointer (it's only valid for the duration of the call)
 * - Return a valid null-terminated UTF-8 string (error message) if validation fails
 * - Return NULL if validation passes
 * - The returned string must be freeable by kreuzberg_free_string
 */
typedef char *(*ValidatorCallback)(const char *result_json);

/**
 * Extract text and metadata from a file (synchronous).
 *
 * # Safety
 *
 * - `file_path` must be a valid null-terminated C string
 * - The returned pointer must be freed with `kreuzberg_free_result`
 * - Returns NULL on error (check `kreuzberg_last_error` for details)
 *
 * # Example (C)
 *
 * ```c
 * const char* path = "/path/to/document.pdf";
 * CExtractionResult* result = kreuzberg_extract_file_sync(path);
 * if (result != NULL && result->success) {
 *     printf("Content: %s\n", result->content);
 *     printf("MIME: %s\n", result->mime_type);
 *     kreuzberg_free_result(result);
 * } else {
 *     const char* error = kreuzberg_last_error();
 *     printf("Error: %s\n", error);
 * }
 * ```
 */
struct CExtractionResult *kreuzberg_extract_file_sync(const char *file_path);

/**
 * Extract text and metadata from a file with custom configuration (synchronous).
 *
 * # Safety
 *
 * - `file_path` must be a valid null-terminated C string
 * - `config_json` must be a valid null-terminated C string containing JSON, or NULL for default config
 * - The returned pointer must be freed with `kreuzberg_free_result`
 * - Returns NULL on error (check `kreuzberg_last_error` for details)
 *
 * # Example (C)
 *
 * ```c
 * const char* path = "/path/to/document.pdf";
 * const char* config = "{\"force_ocr\": true, \"ocr\": {\"language\": \"deu\"}}";
 * CExtractionResult* result = kreuzberg_extract_file_sync_with_config(path, config);
 * if (result != NULL && result->success) {
 *     printf("Content: %s\n", result->content);
 *     kreuzberg_free_result(result);
 * }
 * ```
 */
struct CExtractionResult *kreuzberg_extract_file_sync_with_config(const char *file_path,
                                                                  const char *config_json);

/**
 * Extract text and metadata from byte array (synchronous).
 *
 * # Safety
 *
 * - `data` must be a valid pointer to a byte array of length `data_len`
 * - `mime_type` must be a valid null-terminated C string
 * - The returned pointer must be freed with `kreuzberg_free_result`
 * - Returns NULL on error (check `kreuzberg_last_error` for details)
 *
 * # Example (C)
 *
 * ```c
 * const uint8_t* data = ...; // Document bytes
 * size_t len = ...;           // Length of data
 * const char* mime = "application/pdf";
 * CExtractionResult* result = kreuzberg_extract_bytes_sync(data, len, mime);
 * if (result != NULL && result->success) {
 *     printf("Content: %s\n", result->content);
 *     kreuzberg_free_result(result);
 * } else {
 *     const char* error = kreuzberg_last_error();
 *     printf("Error: %s\n", error);
 * }
 * ```
 */
struct CExtractionResult *kreuzberg_extract_bytes_sync(const uint8_t *data,
                                                       uintptr_t data_len,
                                                       const char *mime_type);

/**
 * Extract text and metadata from byte array with custom configuration (synchronous).
 *
 * # Safety
 *
 * - `data` must be a valid pointer to a byte array of length `data_len`
 * - `mime_type` must be a valid null-terminated C string
 * - `config_json` must be a valid null-terminated C string containing JSON, or NULL for default config
 * - The returned pointer must be freed with `kreuzberg_free_result`
 * - Returns NULL on error (check `kreuzberg_last_error` for details)
 *
 * # Example (C)
 *
 * ```c
 * const uint8_t* data = ...; // Document bytes
 * size_t len = ...;           // Length of data
 * const char* mime = "application/pdf";
 * const char* config = "{\"force_ocr\": true, \"ocr\": {\"language\": \"deu\"}}";
 * CExtractionResult* result = kreuzberg_extract_bytes_sync_with_config(data, len, mime, config);
 * if (result != NULL && result->success) {
 *     printf("Content: %s\n", result->content);
 *     kreuzberg_free_result(result);
 * }
 * ```
 */
struct CExtractionResult *kreuzberg_extract_bytes_sync_with_config(const uint8_t *data,
                                                                   uintptr_t data_len,
                                                                   const char *mime_type,
                                                                   const char *config_json);

/**
 * Batch extract text and metadata from multiple files (synchronous).
 *
 * # Safety
 *
 * - `file_paths` must be a valid pointer to an array of null-terminated C strings
 * - `count` must be the number of file paths in the array
 * - `config_json` must be a valid null-terminated C string containing JSON, or NULL for default config
 * - The returned pointer must be freed with `kreuzberg_free_batch_result`
 * - Returns NULL on error (check `kreuzberg_last_error` for details)
 */
struct CBatchResult *kreuzberg_batch_extract_files_sync(const char *const *file_paths,
                                                        uintptr_t count,
                                                        const char *config_json);

/**
 * Batch extract text and metadata from multiple byte arrays (synchronous).
 *
 * # Safety
 *
 * - `items` must be a valid pointer to an array of CBytesWithMime structures
 * - `count` must be the number of items in the array
 * - `config_json` must be a valid null-terminated C string containing JSON, or NULL for default config
 * - The returned pointer must be freed with `kreuzberg_free_batch_result`
 * - Returns NULL on error (check `kreuzberg_last_error` for details)
 */
struct CBatchResult *kreuzberg_batch_extract_bytes_sync(const struct CBytesWithMime *items,
                                                        uintptr_t count,
                                                        const char *config_json);

/**
 * Load an extraction configuration from a TOML/YAML/JSON file.
 *
 * # Safety
 *
 * - `file_path` must be a valid null-terminated C string
 * - The returned string must be freed with `kreuzberg_free_string`
 * - Returns NULL on error (check `kreuzberg_last_error`)
 */
char *kreuzberg_load_extraction_config_from_file(const char *file_path);

/**
 * Free a batch result returned by batch extraction functions.
 *
 * # Safety
 *
 * - `batch_result` must be a pointer previously returned by a batch extraction function
 * - `batch_result` can be NULL (no-op)
 * - `batch_result` must not be used after this call
 * - All results and strings within the batch result will be freed automatically
 */
void kreuzberg_free_batch_result(struct CBatchResult *batch_result);

/**
 * Free a string returned by Kreuzberg functions.
 *
 * # Safety
 *
 * - `s` must be a string previously returned by a Kreuzberg function
 * - `s` can be NULL (no-op)
 * - `s` must not be used after this call
 *
 * # Example (C)
 *
 * ```c
 * char* str = result->content;
 * kreuzberg_free_string(str);
 * // str is now invalid
 * ```
 */
void kreuzberg_free_string(char *s);

/**
 * Free an extraction result returned by `kreuzberg_extract_file_sync`.
 *
 * # Safety
 *
 * - `result` must be a pointer previously returned by `kreuzberg_extract_file_sync`
 * - `result` can be NULL (no-op)
 * - `result` must not be used after this call
 * - All string fields within the result will be freed automatically
 *
 * # Example (C)
 *
 * ```c
 * CExtractionResult* result = kreuzberg_extract_file_sync(path);
 * // Use result...
 * kreuzberg_free_result(result);
 * // result is now invalid
 * ```
 */
void kreuzberg_free_result(struct CExtractionResult *result);

/**
 * Get the last error message from a failed operation.
 *
 * # Safety
 *
 * - Returns a static string that does not need to be freed
 * - Returns NULL if no error has occurred
 * - The returned string is valid until the next Kreuzberg function call on the same thread
 *
 * # Example (C)
 *
 * ```c
 * CExtractionResult* result = kreuzberg_extract_file_sync(path);
 * if (result == NULL) {
 *     const char* error = kreuzberg_last_error();
 *     if (error != NULL) {
 *         printf("Error: %s\n", error);
 *     }
 * }
 * ```
 */
const char *kreuzberg_last_error(void);

/**
 * Get the library version string.
 *
 * # Safety
 *
 * - Returns a static string that does not need to be freed
 * - The returned string is always valid
 *
 * # Example (C)
 *
 * ```c
 * const char* version = kreuzberg_version();
 * printf("Kreuzberg version: %s\n", version);
 * ```
 */
const char *kreuzberg_version(void);

/**
 * Register a custom OCR backend via FFI callback.
 *
 * # Safety
 *
 * - `name` must be a valid null-terminated C string
 * - `callback` must be a valid function pointer that:
 *   - Does not store the image_bytes pointer
 *   - Returns a null-terminated UTF-8 string or NULL on error
 *   - The returned string must be freeable by kreuzberg_free_string
 * - Returns true on success, false on error (check kreuzberg_last_error)
 *
 * # Example (C)
 *
 * ```c
 * char* my_ocr_backend(const uint8_t* image_bytes, size_t image_length, const char* config_json) {
 *     // Implement OCR logic here
 *     // Return allocated string with result, or NULL on error
 *     return strdup("Extracted text");
 * }
 *
 * bool success = kreuzberg_register_ocr_backend("my-ocr", my_ocr_backend);
 * if (!success) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to register: %s\n", error);
 * }
 * ```
 */
bool kreuzberg_register_ocr_backend(const char *name, OcrBackendCallback callback);

/**
 * Register a custom PostProcessor via FFI callback.
 *
 * # Safety
 *
 * - `name` must be a valid null-terminated C string
 * - `callback` must be a valid function pointer that:
 *   - Does not store the result_json pointer
 *   - Returns a null-terminated UTF-8 JSON string or NULL on error
 *   - The returned string must be freeable by kreuzberg_free_string
 * - `priority` determines the order of execution (higher priority runs first)
 * - Returns true on success, false on error (check kreuzberg_last_error)
 *
 * # Example (C)
 *
 * ```c
 * char* my_post_processor(const char* result_json) {
 *     // Parse result_json, modify it, return JSON string
 *     return strdup("{\"content\":\"PROCESSED\"}");
 * }
 *
 * bool success = kreuzberg_register_post_processor("my-processor", my_post_processor, 100);
 * if (!success) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to register: %s\n", error);
 * }
 * ```
 */
bool kreuzberg_register_post_processor(const char *name,
                                       PostProcessorCallback callback,
                                       int32_t priority);

/**
 * Unregister a PostProcessor by name.
 *
 * # Safety
 *
 * - `name` must be a valid null-terminated C string
 * - Returns true on success, false on error (check kreuzberg_last_error)
 *
 * # Example (C)
 *
 * ```c
 * bool success = kreuzberg_unregister_post_processor("my-processor");
 * if (!success) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to unregister: %s\n", error);
 * }
 * ```
 */
bool kreuzberg_unregister_post_processor(const char *name);

/**
 * Register a custom Validator via FFI callback.
 *
 * # Safety
 *
 * - `name` must be a valid null-terminated C string
 * - `callback` must be a valid function pointer that:
 *   - Does not store the result_json pointer
 *   - Returns a null-terminated UTF-8 string (error message) if validation fails
 *   - Returns NULL if validation passes
 *   - The returned string must be freeable by kreuzberg_free_string
 * - `priority` determines the order of validation (higher priority runs first)
 * - Returns true on success, false on error (check kreuzberg_last_error)
 *
 * # Example (C)
 *
 * ```c
 * char* my_validator(const char* result_json) {
 *     // Parse result_json, validate it
 *     // Return error message if validation fails, NULL if passes
 *     if (invalid) {
 *         return strdup("Validation failed: content too short");
 *     }
 *     return NULL;
 * }
 *
 * bool success = kreuzberg_register_validator("my-validator", my_validator, 100);
 * if (!success) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to register: %s\n", error);
 * }
 * ```
 */
bool kreuzberg_register_validator(const char *name, ValidatorCallback callback, int32_t priority);

/**
 * Unregister a Validator by name.
 *
 * # Safety
 *
 * - `name` must be a valid null-terminated C string
 * - Returns true on success, false on error (check kreuzberg_last_error)
 *
 * # Example (C)
 *
 * ```c
 * bool success = kreuzberg_unregister_validator("my-validator");
 * if (!success) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to unregister: %s\n", error);
 * }
 * ```
 */
bool kreuzberg_unregister_validator(const char *name);

#endif  /* KREUZBERG_FFI_H */
