// Package main provides a command to download and install the Kreuzberg FFI library
// for the current platform from GitHub releases.
//
// Usage:
//
//	go run github.com/kreuzberg-dev/kreuzberg/packages/go/v4/cmd/install@latest
//
// Or build and run:
//
//	go build -o kreuzberg-install ./cmd/install
//	./kreuzberg-install
package main

import (
	"archive/tar"
	"compress/gzip"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"time"
)

const (
	// DefaultVersion is the default version to download if not specified
	DefaultVersion = "4.0.5"
	// BaseURL is the base URL for GitHub releases
	BaseURL = "https://github.com/kreuzberg-dev/kreuzberg/releases/download"
	// DefaultInstallDir is the default installation directory
	DefaultInstallDir = ".kreuzberg"
	// dirPermissions is the directory permission mode (user rwx, group rx, other rx)
	dirPermissions = 0o750
	// filePermissions is the file permission mode (user rw, group r, other r)
	filePermissions = 0o644
	// maxExtractSize is the maximum size of extracted files (500MB) to prevent decompression bombs
	maxExtractSize int64 = 500 * 1024 * 1024
	// httpTimeout is the timeout for HTTP requests
	httpTimeout = 5 * time.Minute
	// osWindows is the constant for Windows OS
	osWindows = "windows"
)

// PlatformMapping maps Go's GOOS/GOARCH to release artifact names
var PlatformMapping = map[string]string{
	"darwin/arm64":  "macos-arm64",
	"linux/amd64":   "linux-x86_64",
	"linux/arm64":   "linux-aarch64",
	"windows/amd64": "windows-x86_64",
}

// GoDir maps platform to Go-style directory names
var GoDir = map[string]string{
	"darwin/arm64":  "darwin_arm64",
	"linux/amd64":   "linux_amd64",
	"linux/arm64":   "linux_arm64",
	"windows/amd64": "windows_amd64",
}

// versionRegex validates semantic versioning format
var versionRegex = regexp.MustCompile(`^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$`)

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	version := flag.String("version", DefaultVersion, "Version to download (e.g., 4.0.5)")
	installDir := flag.String("dir", "", "Installation directory (default: ~/.kreuzberg)")
	showEnv := flag.Bool("env", false, "Only show environment variables for existing installation")
	flag.Parse()

	platform := fmt.Sprintf("%s/%s", runtime.GOOS, runtime.GOARCH)
	releaseName, ok := PlatformMapping[platform]
	if !ok {
		fmt.Fprintf(os.Stderr, "Supported platforms:\n")
		for p := range PlatformMapping {
			fmt.Fprintf(os.Stderr, "  - %s\n", p)
		}
		return fmt.Errorf("unsupported platform: %s", platform)
	}

	goDir, ok := GoDir[platform]
	if !ok {
		return fmt.Errorf("missing Go directory mapping for: %s", platform)
	}

	// Determine installation directory
	targetDir := *installDir
	if targetDir == "" {
		home, err := os.UserHomeDir()
		if err != nil {
			return fmt.Errorf("could not determine home directory: %w", err)
		}
		targetDir = filepath.Join(home, DefaultInstallDir)
	}

	libDir := filepath.Join(targetDir, "lib", goDir)
	libPath := filepath.Join(libDir, "libkreuzberg_ffi.a")
	headerDir := filepath.Join(targetDir, "include")
	headerPath := filepath.Join(headerDir, "kreuzberg.h")

	// If --env flag is set, just show the environment variables
	if *showEnv {
		printEnvVars(libDir, headerDir)
		return nil
	}

	// Check if already installed
	if _, err := os.Stat(libPath); err == nil {
		fmt.Printf("Library already installed at: %s\n", libPath)
		fmt.Println("\nTo reinstall, delete the existing installation first:")
		fmt.Printf("  rm -rf %s\n", targetDir)
		fmt.Println()
		printEnvVars(libDir, headerDir)
		return nil
	}

	// Download the release
	return downloadAndInstall(*version, releaseName, targetDir, goDir, libDir, headerDir, libPath, headerPath)
}

// validateVersion checks that version follows semantic versioning pattern
func validateVersion(version string) error {
	if !versionRegex.MatchString(version) {
		return fmt.Errorf("invalid version format: %s (expected semver like 4.0.5)", version)
	}
	return nil
}

func downloadAndInstall(version, releaseName, targetDir, goDir, libDir, headerDir, libPath, headerPath string) error {
	// Validate version format to prevent URL manipulation
	if err := validateVersion(version); err != nil {
		return err
	}

	platform := fmt.Sprintf("%s/%s", runtime.GOOS, runtime.GOARCH)

	// Construct URL using only known-safe base URL and validated version/releaseName
	url := BaseURL + "/v" + version + "/go-ffi-" + releaseName + ".tar.gz"
	fmt.Printf("Downloading Kreuzberg FFI library v%s for %s...\n", version, platform)
	fmt.Printf("URL: %s\n", url)

	// Create HTTP client with timeout
	client := &http.Client{
		Timeout: httpTimeout,
	}
	resp, err := client.Get(url) //nolint:gosec // URL is constructed from hardcoded base + validated version
	if err != nil {
		return fmt.Errorf("failed to download: %w", err)
	}

	// Ensure response body is closed and drained
	defer closeResponseBody(resp)

	if resp.StatusCode != http.StatusOK {
		if resp.StatusCode == http.StatusNotFound {
			return fmt.Errorf("download failed with status %d - release v%s may not exist or doesn't have artifacts for %s. Check available releases at: https://github.com/kreuzberg-dev/kreuzberg/releases", resp.StatusCode, version, releaseName)
		}
		return fmt.Errorf("download failed with status %d", resp.StatusCode)
	}

	// Check Content-Length to fail fast on oversized downloads
	if resp.ContentLength > 0 && resp.ContentLength > maxExtractSize*2 {
		return fmt.Errorf("download too large: %d bytes (max %d)", resp.ContentLength, maxExtractSize*2)
	}

	// Create directories
	if err := os.MkdirAll(libDir, dirPermissions); err != nil {
		return fmt.Errorf("failed to create lib directory: %w", err)
	}
	if err := os.MkdirAll(headerDir, dirPermissions); err != nil {
		return fmt.Errorf("failed to create include directory: %w", err)
	}

	// Extract the tarball
	fmt.Println("Extracting...")
	if err := extractTarGz(resp.Body, targetDir, goDir); err != nil {
		return fmt.Errorf("failed to extract: %w", err)
	}

	// Verify installation
	if _, err := os.Stat(libPath); os.IsNotExist(err) {
		return fmt.Errorf("library not found after extraction at: %s", libPath)
	}

	fmt.Printf("\nInstallation complete!\n")
	fmt.Printf("Library installed to: %s\n", libPath)
	if _, err := os.Stat(headerPath); err == nil {
		fmt.Printf("Header installed to: %s\n", headerPath)
	}
	fmt.Println()
	printEnvVars(libDir, headerDir)

	return nil
}

// closeResponseBody drains and closes the HTTP response body.
// This is a best-effort operation for cleanup; errors are intentionally not propagated
// since the main operation has already completed.
func closeResponseBody(resp *http.Response) {
	// Drain body to allow connection reuse (ignore errors for best-effort cleanup)
	_, _ = io.Copy(io.Discard, resp.Body) //nolint:errcheck,gosec
	_ = resp.Body.Close()                 //nolint:errcheck,gosec
}

// isPathWithinBase checks if targetPath is safely within baseDir (prevents path traversal)
func isPathWithinBase(targetPath, baseDir string) bool {
	cleanTarget := filepath.Clean(targetPath)
	cleanBase := filepath.Clean(baseDir)
	rel, err := filepath.Rel(cleanBase, cleanTarget)
	if err != nil {
		return false
	}
	// Check that the relative path doesn't escape the base directory
	return !strings.HasPrefix(rel, "..") && !filepath.IsAbs(rel)
}

func extractTarGz(r io.Reader, targetDir, goDir string) (returnErr error) {
	gzr, err := gzip.NewReader(r)
	if err != nil {
		return fmt.Errorf("failed to create gzip reader: %w", err)
	}
	defer func() {
		if closeErr := gzr.Close(); closeErr != nil && returnErr == nil {
			returnErr = fmt.Errorf("failed to close gzip reader: %w", closeErr)
		}
	}()

	tr := tar.NewReader(gzr)

	for {
		header, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return fmt.Errorf("tar read error: %w", err)
		}

		// Only process regular files (prevents symlink attacks)
		if header.Typeflag != tar.TypeReg {
			continue
		}

		// Determine target path based on file type
		var targetPath string

		switch {
		case strings.HasSuffix(header.Name, "libkreuzberg_ffi.a"):
			// Library goes to lib/{platform}/
			targetPath = filepath.Join(targetDir, "lib", goDir, "libkreuzberg_ffi.a")
		case strings.HasSuffix(header.Name, "kreuzberg.h"):
			// Header goes to include/
			targetPath = filepath.Join(targetDir, "include", "kreuzberg.h")
		default:
			// Skip other files
			continue
		}

		// Validate target path is within target directory (prevent path traversal)
		if !isPathWithinBase(targetPath, targetDir) {
			return fmt.Errorf("invalid path in archive: %s", header.Name)
		}

		// Create parent directories
		if err := os.MkdirAll(filepath.Dir(targetPath), dirPermissions); err != nil {
			return fmt.Errorf("failed to create directory: %w", err)
		}

		// Extract file with size limit to prevent decompression bombs
		if err := extractFile(tr, targetPath, header.Size); err != nil {
			return err
		}

		fmt.Printf("  Extracted: %s\n", targetPath)
	}

	return nil
}

func extractFile(r io.Reader, targetPath string, size int64) (returnErr error) {
	// Check size limit
	if size > maxExtractSize {
		return fmt.Errorf("file too large: %d bytes (max %d)", size, maxExtractSize)
	}

	outFile, err := os.OpenFile(targetPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, filePermissions) //nolint:gosec // Path is validated above
	if err != nil {
		return fmt.Errorf("failed to create file %s: %w", targetPath, err)
	}
	defer func() {
		if closeErr := outFile.Close(); closeErr != nil && returnErr == nil {
			returnErr = fmt.Errorf("failed to close file %s: %w", targetPath, closeErr)
		}
	}()

	// Use LimitReader to prevent decompression bombs
	limitedReader := io.LimitReader(r, maxExtractSize)
	if _, err := io.Copy(outFile, limitedReader); err != nil {
		return fmt.Errorf("failed to write file %s: %w", targetPath, err)
	}

	return nil
}

func printEnvVars(libDir, headerDir string) {
	libPath := filepath.Join(libDir, "libkreuzberg_ffi.a")

	// Build platform-specific LDFLAGS
	var ldflags string
	switch runtime.GOOS {
	case "darwin":
		// macOS: Direct path to static library (Apple ld does not support -Bstatic)
		ldflags = fmt.Sprintf("%s -framework CoreFoundation -framework CoreServices -framework SystemConfiguration -framework Security -lc++", libPath)
	case "linux":
		// Linux: Use GNU ld static/dynamic switching
		ldflags = fmt.Sprintf("-L%s -Wl,-Bstatic -lkreuzberg_ffi -Wl,-Bdynamic -lpthread -ldl -lm -lstdc++", libDir)
	case osWindows:
		// Windows: Static library with Windows system libs
		ldflags = fmt.Sprintf("-L%s -lkreuzberg_ffi -lws2_32 -luserenv -lbcrypt -lntdll -static-libgcc -static-libstdc++", libDir)
	default:
		ldflags = fmt.Sprintf("-L%s -lkreuzberg_ffi", libDir)
	}

	fmt.Println("To build Go projects with Kreuzberg, set these environment variables:")
	fmt.Println()

	if runtime.GOOS == osWindows {
		fmt.Printf("  set CGO_CFLAGS=-I%s\n", headerDir)
		fmt.Printf("  set CGO_LDFLAGS=%s\n", ldflags)
	} else {
		fmt.Printf("  export CGO_CFLAGS=\"-I%s\"\n", headerDir)
		fmt.Printf("  export CGO_LDFLAGS=\"%s\"\n", ldflags)
	}

	fmt.Println()
	fmt.Println("Or use them inline:")
	fmt.Println()

	if runtime.GOOS == osWindows {
		fmt.Printf("  CGO_CFLAGS=-I%s CGO_LDFLAGS=\"%s\" go build\n", headerDir, ldflags)
	} else {
		fmt.Printf("  CGO_CFLAGS=\"-I%s\" CGO_LDFLAGS=\"%s\" go build\n", headerDir, ldflags)
	}

	fmt.Println()
	if runtime.GOOS == osWindows {
		fmt.Println("Add to your environment variables for persistence.")
	} else {
		fmt.Println("Add to your shell profile (~/.bashrc, ~/.zshrc, etc.) for persistence.")
	}
}
